<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DA1: Algorithms Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DA1<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_algorithms-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Algorithms Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="algorithms_8h_source.html">algorithms.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a990ac721742db2a62bc3423c705f42ed"><td class="memItemLeft" align="right" valign="top">static string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#a990ac721742db2a62bc3423c705f42ed">T2_1</a> (<a class="el" href="class_graph.html">Graph</a> g, string sourc, string dest)</td></tr>
<tr class="memdesc:a990ac721742db2a62bc3423c705f42ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum number of trains that can simultaneously travel between two given vertices using the Edmonds-Karp algorithm.  <br /></td></tr>
<tr class="separator:a990ac721742db2a62bc3423c705f42ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d982128120360344e859f07895b367"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#a75d982128120360344e859f07895b367">T2_2</a> (<a class="el" href="class_graph.html">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:a75d982128120360344e859f07895b367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a district with a given name in a vector of districts.  <br /></td></tr>
<tr class="separator:a75d982128120360344e859f07895b367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7d568629695330d874b72252251119"><td class="memItemLeft" align="right" valign="top">static vector&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#a4c7d568629695330d874b72252251119">T2_3Districts</a> (<a class="el" href="class_graph.html">Graph</a> *graph, int n)</td></tr>
<tr class="memdesc:a4c7d568629695330d874b72252251119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the districts in a graph by their flow and returns the top n districts. This function separates the edges in a given graph by district and calculates the total flow for each district. It then sorts the districts by their flow in descending order and returns the top n districts with the highest flow.  <br /></td></tr>
<tr class="separator:a4c7d568629695330d874b72252251119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a43ec7a7c7d4aed3ccf91831233ced"><td class="memItemLeft" align="right" valign="top">static vector&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#a88a43ec7a7c7d4aed3ccf91831233ced">T2_3Municipalities</a> (<a class="el" href="class_graph.html">Graph</a> *graph, int n)</td></tr>
<tr class="memdesc:a88a43ec7a7c7d4aed3ccf91831233ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separates edges in a graph by municipality and stores them into a map. This function iterates through each vertex in the given graph and for each adjacent edge, it checks if the destination vertex is in the same municipality as the current vertex. If the vertices are in the same municipality, the edge is added to a vector corresponding to the municipality in a map. The resulting map has keys corresponding to each municipality and values corresponding to vectors of edges.  <br /></td></tr>
<tr class="separator:a88a43ec7a7c7d4aed3ccf91831233ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357ba577dea407cd8e1f1cbfdee13aba"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#a357ba577dea407cd8e1f1cbfdee13aba">T2_4</a> (<a class="el" href="class_graph.html">Graph</a> &amp;g, const string &amp;station)</td></tr>
<tr class="memdesc:a357ba577dea407cd8e1f1cbfdee13aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum number of trains that can simultaneously arrive at a given station using the Edmonds-Karp algorithm.  <br /></td></tr>
<tr class="separator:a357ba577dea407cd8e1f1cbfdee13aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf586ecc7e15be354638a771442e9fa3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#adf586ecc7e15be354638a771442e9fa3">T3_1</a> (const vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;path)</td></tr>
<tr class="memdesc:adf586ecc7e15be354638a771442e9fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes task T3.1 of the project, which involves printing a given path, its flow, and its cost to the console. This function takes a vector of <a class="el" href="class_vertex.html">Vertex</a> pointers representing a path in a graph, and calculates the flow and cost of the path. It then prints the path to the console, along with its flow and cost.  <br /></td></tr>
<tr class="separator:adf586ecc7e15be354638a771442e9fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98b9abe79cd2f82b78c8d2125848fe7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#ad98b9abe79cd2f82b78c8d2125848fe7">T4_1</a> (<a class="el" href="class_graph.html">Graph</a> g, string line, int k, string source, string dest)</td></tr>
<tr class="separator:ad98b9abe79cd2f82b78c8d2125848fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e4ca78df85931c55cdda8dd953a45d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#a55e4ca78df85931c55cdda8dd953a45d">T4_2</a> (<a class="el" href="class_graph.html">Graph</a> g, string line, int k)</td></tr>
<tr class="memdesc:a55e4ca78df85931c55cdda8dd953a45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the maximum number of trains that can simultaneously travel between two specific stations in a reduced graph. This function takes a <a class="el" href="class_graph.html">Graph</a> object representing a reduced graph, as well as two strings representing the source and destination stations, respectively. It calculates the maximum flow between the source and destination vertices in the reduced graph using the calculateMaxFlow function, and converts the result to the maximum number of trains that can simultaneously travel between the stations, assuming a minimum capacity per train. The result is returned as an integer.  <br /></td></tr>
<tr class="separator:a55e4ca78df85931c55cdda8dd953a45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff92606a4424d7aacdd48ea2079dff0"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#a9ff92606a4424d7aacdd48ea2079dff0">getFlowAlongPath</a> (const vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;path)</td></tr>
<tr class="memdesc:a9ff92606a4424d7aacdd48ea2079dff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum weight along a given path in a graph.  <br /></td></tr>
<tr class="separator:a9ff92606a4424d7aacdd48ea2079dff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32dc3cb0c7198774d7a1deb0cdcc28f5"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#a32dc3cb0c7198774d7a1deb0cdcc28f5">getPathCost</a> (const vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;path, double minWeight)</td></tr>
<tr class="memdesc:a32dc3cb0c7198774d7a1deb0cdcc28f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the cost of a path in a graph, taking into account the minimum weight and the type of service. This function takes a vector of vertices representing a path in a graph and a minimum weight, and calculates the total cost of the path, taking into account the type of service used on each edge. If the service is "STANDARD", the cost is multiplied by 2, and if the service is "ALFA PENDULAR", the cost is multiplied by 4.  <br /></td></tr>
<tr class="separator:a32dc3cb0c7198774d7a1deb0cdcc28f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34bedd5cd0132e7dae1d78384c7ee26e"><td class="memItemLeft" align="right" valign="top">static map&lt; string, vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#a34bedd5cd0132e7dae1d78384c7ee26e">separateEdgesByDistrict</a> (<a class="el" href="class_graph.html">Graph</a> *g)</td></tr>
<tr class="memdesc:a34bedd5cd0132e7dae1d78384c7ee26e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separates edges in a graph by district and stores them into a map.  <br /></td></tr>
<tr class="separator:a34bedd5cd0132e7dae1d78384c7ee26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acedce16b1c32798374af6e0f3e3d521a"><td class="memItemLeft" align="right" valign="top">static map&lt; string, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#acedce16b1c32798374af6e0f3e3d521a">calculateDistrictFlows</a> (map&lt; string, vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; &gt; &amp;districtMap)</td></tr>
<tr class="memdesc:acedce16b1c32798374af6e0f3e3d521a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the flow for each district based on the edges in the input map.  <br /></td></tr>
<tr class="separator:acedce16b1c32798374af6e0f3e3d521a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94dfbff9f3d3a63fef47dfa3d3232bcf"><td class="memItemLeft" align="right" valign="top">static map&lt; string, vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#a94dfbff9f3d3a63fef47dfa3d3232bcf">separateEdgesByMunicipality</a> (<a class="el" href="class_graph.html">Graph</a> *graph)</td></tr>
<tr class="memdesc:a94dfbff9f3d3a63fef47dfa3d3232bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function separates edges in a graph by municipality and stores them into a map. This function iterates through each vertex in the given graph and for each adjacent edge, it checks if the destination vertex is in the same municipality as the current vertex. If the vertices are in the same municipality, the edge is added to a vector corresponding to the municipality in a map. The resulting map has keys corresponding to each municipality and values corresponding to vectors of edges.  <br /></td></tr>
<tr class="separator:a94dfbff9f3d3a63fef47dfa3d3232bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc5f235ce16e44ff5c9a406aa2ed81e"><td class="memItemLeft" align="right" valign="top">static map&lt; string, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithms.html#adbc5f235ce16e44ff5c9a406aa2ed81e">calculateMunicipalityFlows</a> (map&lt; string, vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; &gt; &amp;municipalityMap)</td></tr>
<tr class="memdesc:adbc5f235ce16e44ff5c9a406aa2ed81e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the total flow of each municipality from a map of edges separated by municipality. This function takes a map of edges separated by municipality and calculates the total flow for each municipality by iterating over the edges in each vector of the map. The resulting map has keys corresponding to each municipality and values corresponding to the total flow.  <br /></td></tr>
<tr class="separator:adbc5f235ce16e44ff5c9a406aa2ed81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acedce16b1c32798374af6e0f3e3d521a" name="acedce16b1c32798374af6e0f3e3d521a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acedce16b1c32798374af6e0f3e3d521a">&#9670;&#160;</a></span>calculateDistrictFlows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; string, double &gt; Algorithms::calculateDistrictFlows </td>
          <td>(</td>
          <td class="paramtype">map&lt; string, vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>districtMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the flow for each district based on the edges in the input map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">districtMap</td><td>A map where each key is a district name and each value is a vector of edges.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map where each key is a district name and each value is the total flow in that district.</dd></dl>
<p>The time complexity is O(E), where E is the total number of edges in the graph. This is because the function iterates through each vertex in the graph and for each adjacent edge, it checks if the destination vertex is in the same district as the current vertex and adds the edge to a vector corresponding to the district in a map. </p>
<div class="fragment"><div class="line"><span class="lineno">  139</span>                                                                                              {</div>
<div class="line"><span class="lineno">  140</span>    map&lt;string, double&gt; districtFlows;</div>
<div class="line"><span class="lineno">  141</span> </div>
<div class="line"><span class="lineno">  142</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; entry : districtMap) {</div>
<div class="line"><span class="lineno">  143</span>        <span class="keywordtype">string</span> district = entry.first;</div>
<div class="line"><span class="lineno">  144</span>        vector&lt;Edge*&gt; edges = entry.second;</div>
<div class="line"><span class="lineno">  145</span> </div>
<div class="line"><span class="lineno">  146</span>        <span class="comment">// Calculate the total flow for the current district</span></div>
<div class="line"><span class="lineno">  147</span>        <span class="keywordtype">double</span> totalFlow = 0.0;</div>
<div class="line"><span class="lineno">  148</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> edge : edges) {</div>
<div class="line"><span class="lineno">  149</span>            totalFlow += edge-&gt;getWeight();</div>
<div class="line"><span class="lineno">  150</span>        }</div>
<div class="line"><span class="lineno">  151</span> </div>
<div class="line"><span class="lineno">  152</span>        districtFlows[district] = totalFlow;</div>
<div class="line"><span class="lineno">  153</span>    }</div>
<div class="line"><span class="lineno">  154</span> </div>
<div class="line"><span class="lineno">  155</span>    <span class="keywordflow">return</span> districtFlows;</div>
<div class="line"><span class="lineno">  156</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="adbc5f235ce16e44ff5c9a406aa2ed81e" name="adbc5f235ce16e44ff5c9a406aa2ed81e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbc5f235ce16e44ff5c9a406aa2ed81e">&#9670;&#160;</a></span>calculateMunicipalityFlows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; string, double &gt; Algorithms::calculateMunicipalityFlows </td>
          <td>(</td>
          <td class="paramtype">map&lt; string, vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>municipalityMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the total flow of each municipality from a map of edges separated by municipality. This function takes a map of edges separated by municipality and calculates the total flow for each municipality by iterating over the edges in each vector of the map. The resulting map has keys corresponding to each municipality and values corresponding to the total flow. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">municipalityMap</td><td>A map where each key is a municipality name and each value is a vector of edges.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map where each key is a municipality name and each value is the total flow.</dd></dl>
<p>@complexity The time complexity of this function is O(NM) where N is the number of vertices in the graph and M is the number of edges connected to each vertex. The space complexity is also O(NM) due to the use of a map to store the municipality flows. </p>
<div class="fragment"><div class="line"><span class="lineno">  202</span>                                                                                                      {</div>
<div class="line"><span class="lineno">  203</span>    map&lt;string, double&gt; municipalityFlows;</div>
<div class="line"><span class="lineno">  204</span> </div>
<div class="line"><span class="lineno">  205</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; entry : municipalityMap) {</div>
<div class="line"><span class="lineno">  206</span>        <span class="keywordtype">string</span> municipality = entry.first;</div>
<div class="line"><span class="lineno">  207</span>        vector&lt;Edge*&gt; edges = entry.second;</div>
<div class="line"><span class="lineno">  208</span> </div>
<div class="line"><span class="lineno">  209</span>        <span class="comment">// Calculate the total flow for the current municipality</span></div>
<div class="line"><span class="lineno">  210</span>        <span class="keywordtype">double</span> totalFlow = 0.0;</div>
<div class="line"><span class="lineno">  211</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> edge : edges) {</div>
<div class="line"><span class="lineno">  212</span>            totalFlow += edge-&gt;getWeight();</div>
<div class="line"><span class="lineno">  213</span>        }</div>
<div class="line"><span class="lineno">  214</span> </div>
<div class="line"><span class="lineno">  215</span>        municipalityFlows[municipality] = totalFlow;</div>
<div class="line"><span class="lineno">  216</span>    }</div>
<div class="line"><span class="lineno">  217</span> </div>
<div class="line"><span class="lineno">  218</span>    <span class="keywordflow">return</span> municipalityFlows;</div>
<div class="line"><span class="lineno">  219</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9ff92606a4424d7aacdd48ea2079dff0" name="a9ff92606a4424d7aacdd48ea2079dff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff92606a4424d7aacdd48ea2079dff0">&#9670;&#160;</a></span>getFlowAlongPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Algorithms::getFlowAlongPath </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the minimum weight along a given path in a graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A vector of vertices representing the path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum weight along the path.</dd></dl>
<p>The time complexity of this function is O(|E|), where |E| is the number of edges in the graph. </p>
<div class="fragment"><div class="line"><span class="lineno">  345</span>                                                               {</div>
<div class="line"><span class="lineno">  346</span>    <span class="keywordtype">double</span> minWeight = INFINITY;</div>
<div class="line"><span class="lineno">  347</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; path.size() - 1; i++) {</div>
<div class="line"><span class="lineno">  348</span>        <a class="code hl_class" href="class_vertex.html">Vertex</a> *v = path[i];</div>
<div class="line"><span class="lineno">  349</span>        <a class="code hl_class" href="class_vertex.html">Vertex</a> *w = path[i+1];</div>
<div class="line"><span class="lineno">  350</span>        <span class="keywordtype">double</span> weight = INFINITY;</div>
<div class="line"><span class="lineno">  351</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : v-&gt;<a class="code hl_function" href="class_vertex.html#a9858f2aa388d2bfb49d9df8f4504b5a0">getAdj</a>()) {</div>
<div class="line"><span class="lineno">  352</span>            <span class="keywordflow">if</span> (e-&gt;getDest() == w) {</div>
<div class="line"><span class="lineno">  353</span>                weight = e-&gt;getWeight();</div>
<div class="line"><span class="lineno">  354</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  355</span>            }</div>
<div class="line"><span class="lineno">  356</span>        }</div>
<div class="line"><span class="lineno">  357</span>        <span class="keywordflow">if</span> (weight &lt; minWeight) {</div>
<div class="line"><span class="lineno">  358</span>            minWeight = weight;</div>
<div class="line"><span class="lineno">  359</span>        }</div>
<div class="line"><span class="lineno">  360</span>    }</div>
<div class="line"><span class="lineno">  361</span>    <span class="keywordflow">return</span> minWeight;</div>
<div class="line"><span class="lineno">  362</span>}</div>
<div class="ttc" id="aclass_vertex_html"><div class="ttname"><a href="class_vertex.html">Vertex</a></div><div class="ttdef"><b>Definition:</b> vertexEdge.h:18</div></div>
<div class="ttc" id="aclass_vertex_html_a9858f2aa388d2bfb49d9df8f4504b5a0"><div class="ttname"><a href="class_vertex.html#a9858f2aa388d2bfb49d9df8f4504b5a0">Vertex::getAdj</a></div><div class="ttdeci">vector&lt; Edge * &gt; getAdj() const</div><div class="ttdef"><b>Definition:</b> vertexEdge.cpp:92</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a32dc3cb0c7198774d7a1deb0cdcc28f5" name="a32dc3cb0c7198774d7a1deb0cdcc28f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32dc3cb0c7198774d7a1deb0cdcc28f5">&#9670;&#160;</a></span>getPathCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Algorithms::getPathCost </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minWeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the cost of a path in a graph, taking into account the minimum weight and the type of service. This function takes a vector of vertices representing a path in a graph and a minimum weight, and calculates the total cost of the path, taking into account the type of service used on each edge. If the service is "STANDARD", the cost is multiplied by 2, and if the service is "ALFA PENDULAR", the cost is multiplied by 4. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A vector of <a class="el" href="class_vertex.html">Vertex</a> pointers representing the path in the graph. </td></tr>
    <tr><td class="paramname">minWeight</td><td>The minimum weight to be considered in the cost calculation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total cost of the path, taking into account the type of service used on each edge. The space complexity is O(1), since the function uses only a few local variables to calculate the cost. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  375</span>                                                                            {</div>
<div class="line"><span class="lineno">  376</span>    <span class="keywordtype">double</span> cost = 0;</div>
<div class="line"><span class="lineno">  377</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; path.size() - 1; i++) {</div>
<div class="line"><span class="lineno">  378</span>        <a class="code hl_class" href="class_vertex.html">Vertex</a> *v = path[i];</div>
<div class="line"><span class="lineno">  379</span>        <a class="code hl_class" href="class_vertex.html">Vertex</a> *w = path[i+1];</div>
<div class="line"><span class="lineno">  380</span>        <span class="keywordtype">double</span> weight = INFINITY;</div>
<div class="line"><span class="lineno">  381</span>        <span class="keywordtype">string</span> service = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><span class="lineno">  382</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : v-&gt;<a class="code hl_function" href="class_vertex.html#a9858f2aa388d2bfb49d9df8f4504b5a0">getAdj</a>()) {</div>
<div class="line"><span class="lineno">  383</span>            <span class="keywordflow">if</span> (e-&gt;getDest() == w) {</div>
<div class="line"><span class="lineno">  384</span>                weight = e-&gt;getWeight();</div>
<div class="line"><span class="lineno">  385</span>                service = e-&gt;getService();</div>
<div class="line"><span class="lineno">  386</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  387</span>            }</div>
<div class="line"><span class="lineno">  388</span>        }</div>
<div class="line"><span class="lineno">  389</span>        <span class="keywordflow">if</span> (service == <span class="stringliteral">&quot;STANDARD&quot;</span>) {</div>
<div class="line"><span class="lineno">  390</span>            cost += minWeight * 2;</div>
<div class="line"><span class="lineno">  391</span>        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (service == <span class="stringliteral">&quot;ALFA PENDULAR&quot;</span>) {</div>
<div class="line"><span class="lineno">  392</span>            cost += minWeight * 4;</div>
<div class="line"><span class="lineno">  393</span>        }</div>
<div class="line"><span class="lineno">  394</span>    }</div>
<div class="line"><span class="lineno">  395</span>    <span class="keywordflow">return</span> cost;</div>
<div class="line"><span class="lineno">  396</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a34bedd5cd0132e7dae1d78384c7ee26e" name="a34bedd5cd0132e7dae1d78384c7ee26e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34bedd5cd0132e7dae1d78384c7ee26e">&#9670;&#160;</a></span>separateEdgesByDistrict()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; string, vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; &gt; Algorithms::separateEdgesByDistrict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Separates edges in a graph by district and stores them into a map. </p>
<p>This function iterates through each vertex in the given graph and for each adjacent edge, it checks if the destination vertex is in the same district as the current vertex. If the vertices are in the same district, the edge is added to a vector corresponding to the district in a map. The resulting map has keys corresponding to each district and values corresponding to vectors of edges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>Pointer to the graph object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map where each key is a district name and each value is a vector of edges</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function has a time complexity of O(|V|*|E|) since it needs to iterate through all vertices and adjacent edges to check if they are in the same district. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  111</span>                                                                           {</div>
<div class="line"><span class="lineno">  112</span>    map&lt;string, vector&lt;Edge*&gt;&gt; districtMap;</div>
<div class="line"><span class="lineno">  113</span> </div>
<div class="line"><span class="lineno">  114</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> vertex : graph-&gt;<a class="code hl_function" href="class_graph.html#a56576f9c2ee0afadc4b77dcbe3acb704">getVertexSet</a>()) {</div>
<div class="line"><span class="lineno">  115</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> edge : vertex-&gt;getAdj()) {</div>
<div class="line"><span class="lineno">  116</span>            <a class="code hl_class" href="class_vertex.html">Vertex</a>* destVertex = edge-&gt;getDest();</div>
<div class="line"><span class="lineno">  117</span>            <span class="keywordflow">if</span> (vertex-&gt;getDistrict() == destVertex-&gt;<a class="code hl_function" href="class_vertex.html#a45cb9578e36b1a584620c191ac3dd003">getDistrict</a>()) {</div>
<div class="line"><span class="lineno">  118</span>                <span class="keywordtype">string</span> district = vertex-&gt;<a class="code hl_function" href="class_vertex.html#a45cb9578e36b1a584620c191ac3dd003">getDistrict</a>();</div>
<div class="line"><span class="lineno">  119</span>                districtMap[district].push_back(edge);</div>
<div class="line"><span class="lineno">  120</span>            }</div>
<div class="line"><span class="lineno">  121</span>        }</div>
<div class="line"><span class="lineno">  122</span>    }</div>
<div class="line"><span class="lineno">  123</span> </div>
<div class="line"><span class="lineno">  124</span>    <span class="keywordflow">return</span> districtMap;</div>
<div class="line"><span class="lineno">  125</span>}</div>
<div class="ttc" id="aclass_graph_html_a56576f9c2ee0afadc4b77dcbe3acb704"><div class="ttname"><a href="class_graph.html#a56576f9c2ee0afadc4b77dcbe3acb704">Graph::getVertexSet</a></div><div class="ttdeci">vector&lt; Vertex * &gt; getVertexSet() const</div><div class="ttdef"><b>Definition:</b> newGraph.cpp:11</div></div>
<div class="ttc" id="aclass_vertex_html_a45cb9578e36b1a584620c191ac3dd003"><div class="ttname"><a href="class_vertex.html#a45cb9578e36b1a584620c191ac3dd003">Vertex::getDistrict</a></div><div class="ttdeci">string getDistrict() const</div><div class="ttdef"><b>Definition:</b> vertexEdge.cpp:76</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a94dfbff9f3d3a63fef47dfa3d3232bcf" name="a94dfbff9f3d3a63fef47dfa3d3232bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94dfbff9f3d3a63fef47dfa3d3232bcf">&#9670;&#160;</a></span>separateEdgesByMunicipality()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; string, vector&lt; <a class="el" href="class_edge.html">Edge</a> * &gt; &gt; Algorithms::separateEdgesByMunicipality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function separates edges in a graph by municipality and stores them into a map. This function iterates through each vertex in the given graph and for each adjacent edge, it checks if the destination vertex is in the same municipality as the current vertex. If the vertices are in the same municipality, the edge is added to a vector corresponding to the municipality in a map. The resulting map has keys corresponding to each municipality and values corresponding to vectors of edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>Pointer to the graph object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map where each key is a municipality name and each value is a vector of edges.</dd></dl>
<p>@complexity O(V * E), where V is the number of vertices in the graph and E is the number of edges. The function iterates through each vertex and its adjacent edges, therefore its time complexity is proportional to the number of vertices and edges in the graph. </p>
<div class="fragment"><div class="line"><span class="lineno">  173</span>                                                                               {</div>
<div class="line"><span class="lineno">  174</span>    map&lt;string, vector&lt;Edge*&gt;&gt; municipalityMap;</div>
<div class="line"><span class="lineno">  175</span> </div>
<div class="line"><span class="lineno">  176</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> vertex : graph-&gt;<a class="code hl_function" href="class_graph.html#a56576f9c2ee0afadc4b77dcbe3acb704">getVertexSet</a>()) {</div>
<div class="line"><span class="lineno">  177</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> edge : vertex-&gt;getAdj()) {</div>
<div class="line"><span class="lineno">  178</span>            <a class="code hl_class" href="class_vertex.html">Vertex</a>* destVertex = edge-&gt;getDest();</div>
<div class="line"><span class="lineno">  179</span>            <span class="keywordflow">if</span> (vertex-&gt;getMunicipality() == destVertex-&gt;<a class="code hl_function" href="class_vertex.html#a72cabbe71318b26964e0f6d3cf0fb96b">getMunicipality</a>()) {</div>
<div class="line"><span class="lineno">  180</span>                <span class="keywordtype">string</span> municipality = vertex-&gt;<a class="code hl_function" href="class_vertex.html#a72cabbe71318b26964e0f6d3cf0fb96b">getMunicipality</a>();</div>
<div class="line"><span class="lineno">  181</span>                municipalityMap[municipality].push_back(edge);</div>
<div class="line"><span class="lineno">  182</span>            }</div>
<div class="line"><span class="lineno">  183</span>        }</div>
<div class="line"><span class="lineno">  184</span>    }</div>
<div class="line"><span class="lineno">  185</span> </div>
<div class="line"><span class="lineno">  186</span>    <span class="keywordflow">return</span> municipalityMap;</div>
<div class="line"><span class="lineno">  187</span>}</div>
<div class="ttc" id="aclass_vertex_html_a72cabbe71318b26964e0f6d3cf0fb96b"><div class="ttname"><a href="class_vertex.html#a72cabbe71318b26964e0f6d3cf0fb96b">Vertex::getMunicipality</a></div><div class="ttdeci">string getMunicipality() const</div><div class="ttdef"><b>Definition:</b> vertexEdge.cpp:80</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a990ac721742db2a62bc3423c705f42ed" name="a990ac721742db2a62bc3423c705f42ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a990ac721742db2a62bc3423c705f42ed">&#9670;&#160;</a></span>T2_1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string Algorithms::T2_1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>sourc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the maximum number of trains that can simultaneously travel between two given vertices using the Edmonds-Karp algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The input graph.</td></tr>
    <tr><td class="paramname">sourc</td><td>The name of the source vertex.</td></tr>
    <tr><td class="paramname">dest</td><td>The name of the destination vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string with the result of the computation.</dd></dl>
<p>Computes the pair of vertices with the highest flow between them using the Edmonds-Karp algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The input graph.</td></tr>
  </table>
  </dd>
</dl>
<p>The time complexity of this function is O(|V|^2 * |E|), where |V| is the number of vertices in the graph and |E| is the number of edges in the graph. </p>
<div class="fragment"><div class="line"><span class="lineno">   32</span>                                                          {</div>
<div class="line"><span class="lineno">   33</span> </div>
<div class="line"><span class="lineno">   34</span>    g.<a class="code hl_function" href="class_graph.html#a498e1372f6f65cfc080f92c3ad8ab9bf">edmondsKarp</a>(sourc, dest);</div>
<div class="line"><span class="lineno">   35</span> </div>
<div class="line"><span class="lineno">   36</span>    <span class="keyword">auto</span> v = g.<a class="code hl_function" href="class_graph.html#afe0028a29236a09c9e056a3e7f4c1c08">findVertex</a>(sourc);</div>
<div class="line"><span class="lineno">   37</span> </div>
<div class="line"><span class="lineno">   38</span>    <span class="keywordtype">int</span> flow = 0;</div>
<div class="line"><span class="lineno">   39</span> </div>
<div class="line"><span class="lineno">   40</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> e : v-&gt;getAdj()){</div>
<div class="line"><span class="lineno">   41</span>        flow += e-&gt;getFlow();</div>
<div class="line"><span class="lineno">   42</span>    }</div>
<div class="line"><span class="lineno">   43</span> </div>
<div class="line"><span class="lineno">   44</span>    <span class="keywordflow">return</span> <span class="stringliteral">&quot;The maximum number of trains that can simultaneously travel between &quot;</span> + sourc + <span class="stringliteral">&quot; and &quot;</span> + dest + <span class="stringliteral">&quot; is &quot;</span> + to_string(flow) + <span class="stringliteral">&quot; trains&quot;</span>;</div>
<div class="line"><span class="lineno">   45</span> </div>
<div class="line"><span class="lineno">   46</span>}</div>
<div class="ttc" id="aclass_graph_html_a498e1372f6f65cfc080f92c3ad8ab9bf"><div class="ttname"><a href="class_graph.html#a498e1372f6f65cfc080f92c3ad8ab9bf">Graph::edmondsKarp</a></div><div class="ttdeci">void edmondsKarp(string source, string target)</div><div class="ttdoc">Applies the Edmonds-Karp algorithm to find the maximum flow in the graph from a given source to a giv...</div><div class="ttdef"><b>Definition:</b> newGraph.cpp:296</div></div>
<div class="ttc" id="aclass_graph_html_afe0028a29236a09c9e056a3e7f4c1c08"><div class="ttname"><a href="class_graph.html#afe0028a29236a09c9e056a3e7f4c1c08">Graph::findVertex</a></div><div class="ttdeci">Vertex * findVertex(const string &amp;name) const</div><div class="ttdoc">Finds a vertex in the graph given its name. This function iterates through the vertex set of the grap...</div><div class="ttdef"><b>Definition:</b> newGraph.cpp:27</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a75d982128120360344e859f07895b367" name="a75d982128120360344e859f07895b367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d982128120360344e859f07895b367">&#9670;&#160;</a></span>T2_2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Algorithms::T2_2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a district with a given name in a vector of districts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the district to be found.</td></tr>
    <tr><td class="paramname">districts</td><td>The vector of districts to search.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the district with the given name, or nullptr if it is not found.</dd></dl>
<p>Computes the district with the highest flow of trains using the Edmonds-Karp algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The input graph.</td></tr>
  </table>
  </dd>
</dl>
<p>The time complexity of this function is O(|V|^4 * |E|), where |V| is the number of vertices in the graph and |E| is the number of edges in the graph. </p>
<div class="fragment"><div class="line"><span class="lineno">   68</span>                              {</div>
<div class="line"><span class="lineno">   69</span>    <span class="keywordtype">double</span> maxFlow = 0;</div>
<div class="line"><span class="lineno">   70</span>    pair&lt;Vertex*, Vertex*&gt; maxFlowPair;</div>
<div class="line"><span class="lineno">   71</span> </div>
<div class="line"><span class="lineno">   72</span>    vector&lt;Vertex*&gt; vertices = g.<a class="code hl_function" href="class_graph.html#a56576f9c2ee0afadc4b77dcbe3acb704">getVertexSet</a>();</div>
<div class="line"><span class="lineno">   73</span> </div>
<div class="line"><span class="lineno">   74</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> u : vertices) {</div>
<div class="line"><span class="lineno">   75</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> v : vertices) {</div>
<div class="line"><span class="lineno">   76</span>            <span class="keywordflow">if</span> (u != v) {</div>
<div class="line"><span class="lineno">   77</span>                g.<a class="code hl_function" href="class_graph.html#a498e1372f6f65cfc080f92c3ad8ab9bf">edmondsKarp</a>(u-&gt;getName(), v-&gt;getName());</div>
<div class="line"><span class="lineno">   78</span> </div>
<div class="line"><span class="lineno">   79</span>                <span class="keywordtype">double</span> flow = 0;</div>
<div class="line"><span class="lineno">   80</span>                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> e : u-&gt;getAdj()) {</div>
<div class="line"><span class="lineno">   81</span>                    flow += e-&gt;getFlow();</div>
<div class="line"><span class="lineno">   82</span>                }</div>
<div class="line"><span class="lineno">   83</span> </div>
<div class="line"><span class="lineno">   84</span>                <span class="keywordflow">if</span> (flow &gt;= maxFlow) {</div>
<div class="line"><span class="lineno">   85</span>                    maxFlow = flow;</div>
<div class="line"><span class="lineno">   86</span>                    maxFlowPair = {u, v};</div>
<div class="line"><span class="lineno">   87</span>                }</div>
<div class="line"><span class="lineno">   88</span>            }</div>
<div class="line"><span class="lineno">   89</span>        }</div>
<div class="line"><span class="lineno">   90</span>    }</div>
<div class="line"><span class="lineno">   91</span> </div>
<div class="line"><span class="lineno">   92</span>    cout &lt;&lt; <span class="stringliteral">&quot;The pair with the highest flow is: (&quot;</span> &lt;&lt; maxFlowPair.first-&gt;getName() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; maxFlowPair.second-&gt;getName() &lt;&lt; <span class="stringliteral">&quot;) with a flow of &quot;</span> &lt;&lt; maxFlow &lt;&lt; endl;</div>
<div class="line"><span class="lineno">   93</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4c7d568629695330d874b72252251119" name="a4c7d568629695330d874b72252251119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7d568629695330d874b72252251119">&#9670;&#160;</a></span>T2_3Districts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; string &gt; Algorithms::T2_3Districts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the districts in a graph by their flow and returns the top n districts. This function separates the edges in a given graph by district and calculates the total flow for each district. It then sorts the districts by their flow in descending order and returns the top n districts with the highest flow. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>Pointer to the graph object.</td></tr>
    <tr><td class="paramname">n</td><td>Number of top districts to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of strings with the names of the top n districts sorted by flow.</dd></dl>
<p>@complexity The time complexity of this function is O(mnlogn), where m is the number of edges in the graph and n is the number of districts. This is because the function calls the separateEdgesByDistrict and calculateDistrictFlows functions, both of which have a time complexity of O(m), and then sorts the resulting map, which has a size of n, using the sort function, which has a time complexity of O(nlogn). </p>
<div class="fragment"><div class="line"><span class="lineno">  236</span>                                                            {</div>
<div class="line"><span class="lineno">  237</span>    <span class="comment">// Separate edges by district</span></div>
<div class="line"><span class="lineno">  238</span>    map&lt;string, vector&lt;Edge*&gt;&gt; districtMap = <a class="code hl_function" href="class_algorithms.html#a34bedd5cd0132e7dae1d78384c7ee26e">separateEdgesByDistrict</a>(graph);</div>
<div class="line"><span class="lineno">  239</span> </div>
<div class="line"><span class="lineno">  240</span>    <span class="comment">// Calculate district flows</span></div>
<div class="line"><span class="lineno">  241</span>    map&lt;string, double&gt; districtFlows = <a class="code hl_function" href="class_algorithms.html#acedce16b1c32798374af6e0f3e3d521a">calculateDistrictFlows</a>(districtMap);</div>
<div class="line"><span class="lineno">  242</span> </div>
<div class="line"><span class="lineno">  243</span>    <span class="comment">// Sort districts by flow (in descending order)</span></div>
<div class="line"><span class="lineno">  244</span>    vector&lt;pair&lt;string, double&gt;&gt; sortedDistricts(districtFlows.begin(), districtFlows.end());</div>
<div class="line"><span class="lineno">  245</span>    sort(sortedDistricts.begin(), sortedDistricts.end(), [](<span class="keyword">const</span> pair&lt;string, double&gt;&amp; a, <span class="keyword">const</span> pair&lt;string, double&gt;&amp; b) {</div>
<div class="line"><span class="lineno">  246</span>        return a.second &gt; b.second;</div>
<div class="line"><span class="lineno">  247</span>    });</div>
<div class="line"><span class="lineno">  248</span> </div>
<div class="line"><span class="lineno">  249</span>    <span class="comment">// Return top four districts</span></div>
<div class="line"><span class="lineno">  250</span>    vector&lt;string&gt; topDistricts;</div>
<div class="line"><span class="lineno">  251</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n &amp;&amp; i &lt; sortedDistricts.size(); i++) {</div>
<div class="line"><span class="lineno">  252</span>        topDistricts.push_back(sortedDistricts[i].first);</div>
<div class="line"><span class="lineno">  253</span>    }</div>
<div class="line"><span class="lineno">  254</span> </div>
<div class="line"><span class="lineno">  255</span>    <span class="keywordflow">return</span> topDistricts;</div>
<div class="line"><span class="lineno">  256</span>}</div>
<div class="ttc" id="aclass_algorithms_html_a34bedd5cd0132e7dae1d78384c7ee26e"><div class="ttname"><a href="class_algorithms.html#a34bedd5cd0132e7dae1d78384c7ee26e">Algorithms::separateEdgesByDistrict</a></div><div class="ttdeci">static map&lt; string, vector&lt; Edge * &gt; &gt; separateEdgesByDistrict(Graph *g)</div><div class="ttdoc">Separates edges in a graph by district and stores them into a map.</div><div class="ttdef"><b>Definition:</b> algorithms.cpp:111</div></div>
<div class="ttc" id="aclass_algorithms_html_acedce16b1c32798374af6e0f3e3d521a"><div class="ttname"><a href="class_algorithms.html#acedce16b1c32798374af6e0f3e3d521a">Algorithms::calculateDistrictFlows</a></div><div class="ttdeci">static map&lt; string, double &gt; calculateDistrictFlows(map&lt; string, vector&lt; Edge * &gt; &gt; &amp;districtMap)</div><div class="ttdoc">Calculates the flow for each district based on the edges in the input map.</div><div class="ttdef"><b>Definition:</b> algorithms.cpp:139</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a88a43ec7a7c7d4aed3ccf91831233ced" name="a88a43ec7a7c7d4aed3ccf91831233ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a43ec7a7c7d4aed3ccf91831233ced">&#9670;&#160;</a></span>T2_3Municipalities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; string &gt; Algorithms::T2_3Municipalities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Separates edges in a graph by municipality and stores them into a map. This function iterates through each vertex in the given graph and for each adjacent edge, it checks if the destination vertex is in the same municipality as the current vertex. If the vertices are in the same municipality, the edge is added to a vector corresponding to the municipality in a map. The resulting map has keys corresponding to each municipality and values corresponding to vectors of edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>Pointer to the graph object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map where each key is a municipality name and each value is a vector of edges.</dd></dl>
<p>@complexity O(|V||E|) where |V| is the number of vertices and |E| is the number of edges in the graph. </p>
<div class="fragment"><div class="line"><span class="lineno">  270</span>                                                                 {</div>
<div class="line"><span class="lineno">  271</span>    <span class="comment">// Separate edges by municipality</span></div>
<div class="line"><span class="lineno">  272</span>    map&lt;string, vector&lt;Edge*&gt;&gt; municipalityMap = <a class="code hl_function" href="class_algorithms.html#a94dfbff9f3d3a63fef47dfa3d3232bcf">separateEdgesByMunicipality</a>(graph);</div>
<div class="line"><span class="lineno">  273</span> </div>
<div class="line"><span class="lineno">  274</span>    <span class="comment">// Calculate municipality flows</span></div>
<div class="line"><span class="lineno">  275</span>    map&lt;string, double&gt; municipalityFlows = <a class="code hl_function" href="class_algorithms.html#adbc5f235ce16e44ff5c9a406aa2ed81e">calculateMunicipalityFlows</a>(municipalityMap);</div>
<div class="line"><span class="lineno">  276</span> </div>
<div class="line"><span class="lineno">  277</span>    <span class="comment">// Sort municipalities by flow (in descending order)</span></div>
<div class="line"><span class="lineno">  278</span>    vector&lt;pair&lt;string, double&gt;&gt; sortedMunicipalities(municipalityFlows.begin(), municipalityFlows.end());</div>
<div class="line"><span class="lineno">  279</span>    sort(sortedMunicipalities.begin(), sortedMunicipalities.end(), [](<span class="keyword">const</span> pair&lt;string, double&gt;&amp; a, <span class="keyword">const</span> pair&lt;string, double&gt;&amp; b) {</div>
<div class="line"><span class="lineno">  280</span>        return a.second &gt; b.second;</div>
<div class="line"><span class="lineno">  281</span>    });</div>
<div class="line"><span class="lineno">  282</span> </div>
<div class="line"><span class="lineno">  283</span>    <span class="comment">// Return top n municipalities</span></div>
<div class="line"><span class="lineno">  284</span>    vector&lt;string&gt; topMunicipalities;</div>
<div class="line"><span class="lineno">  285</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n &amp;&amp; i &lt; sortedMunicipalities.size(); i++) {</div>
<div class="line"><span class="lineno">  286</span>        topMunicipalities.push_back(sortedMunicipalities[i].first);</div>
<div class="line"><span class="lineno">  287</span>    }</div>
<div class="line"><span class="lineno">  288</span> </div>
<div class="line"><span class="lineno">  289</span>    <span class="keywordflow">return</span> topMunicipalities;</div>
<div class="line"><span class="lineno">  290</span>}</div>
<div class="ttc" id="aclass_algorithms_html_a94dfbff9f3d3a63fef47dfa3d3232bcf"><div class="ttname"><a href="class_algorithms.html#a94dfbff9f3d3a63fef47dfa3d3232bcf">Algorithms::separateEdgesByMunicipality</a></div><div class="ttdeci">static map&lt; string, vector&lt; Edge * &gt; &gt; separateEdgesByMunicipality(Graph *graph)</div><div class="ttdoc">This function separates edges in a graph by municipality and stores them into a map....</div><div class="ttdef"><b>Definition:</b> algorithms.cpp:173</div></div>
<div class="ttc" id="aclass_algorithms_html_adbc5f235ce16e44ff5c9a406aa2ed81e"><div class="ttname"><a href="class_algorithms.html#adbc5f235ce16e44ff5c9a406aa2ed81e">Algorithms::calculateMunicipalityFlows</a></div><div class="ttdeci">static map&lt; string, double &gt; calculateMunicipalityFlows(map&lt; string, vector&lt; Edge * &gt; &gt; &amp;municipalityMap)</div><div class="ttdoc">Calculates the total flow of each municipality from a map of edges separated by municipality....</div><div class="ttdef"><b>Definition:</b> algorithms.cpp:202</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a357ba577dea407cd8e1f1cbfdee13aba" name="a357ba577dea407cd8e1f1cbfdee13aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357ba577dea407cd8e1f1cbfdee13aba">&#9670;&#160;</a></span>T2_4()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Algorithms::T2_4 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>station</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the maximum number of trains that can simultaneously arrive at a given station using the Edmonds-Karp algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The input graph.</td></tr>
    <tr><td class="paramname">station</td><td>The name of the station to compute the maximum flow of trains.</td></tr>
  </table>
  </dd>
</dl>
<p>The time complexity of this function is O(|V|^3 * |E|), where |V| is the number of vertices in the graph and |E| is the number of edges in the graph. </p>
<div class="fragment"><div class="line"><span class="lineno">  307</span>                                                     {</div>
<div class="line"><span class="lineno">  308</span>    <span class="keywordtype">double</span> maxFlow = 0;</div>
<div class="line"><span class="lineno">  309</span> </div>
<div class="line"><span class="lineno">  310</span>    <a class="code hl_class" href="class_vertex.html">Vertex</a> *dest = g.<a class="code hl_function" href="class_graph.html#afe0028a29236a09c9e056a3e7f4c1c08">findVertex</a>(station);</div>
<div class="line"><span class="lineno">  311</span>    <span class="keywordflow">if</span> (dest == <span class="keyword">nullptr</span>) {</div>
<div class="line"><span class="lineno">  312</span>        cout &lt;&lt; <span class="stringliteral">&quot;Station not found in the graph.&quot;</span> &lt;&lt; endl;</div>
<div class="line"><span class="lineno">  313</span>        <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  314</span>    }</div>
<div class="line"><span class="lineno">  315</span> </div>
<div class="line"><span class="lineno">  316</span>    vector&lt;Vertex *&gt; vertices = g.<a class="code hl_function" href="class_graph.html#a56576f9c2ee0afadc4b77dcbe3acb704">getVertexSet</a>();</div>
<div class="line"><span class="lineno">  317</span> </div>
<div class="line"><span class="lineno">  318</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;source : vertices) {</div>
<div class="line"><span class="lineno">  319</span>        <span class="keywordflow">if</span> (source-&gt;getName() != station) {</div>
<div class="line"><span class="lineno">  320</span>            g.<a class="code hl_function" href="class_graph.html#a498e1372f6f65cfc080f92c3ad8ab9bf">edmondsKarp</a>(source-&gt;getName(), station);</div>
<div class="line"><span class="lineno">  321</span>            <span class="keywordtype">double</span> flow = 0;</div>
<div class="line"><span class="lineno">  322</span> </div>
<div class="line"><span class="lineno">  323</span>            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;e : source-&gt;getAdj()) {</div>
<div class="line"><span class="lineno">  324</span>                <span class="keywordflow">if</span> (e-&gt;getDest() == dest) {</div>
<div class="line"><span class="lineno">  325</span>                    flow += e-&gt;getFlow();</div>
<div class="line"><span class="lineno">  326</span>                }</div>
<div class="line"><span class="lineno">  327</span>            }</div>
<div class="line"><span class="lineno">  328</span>            maxFlow += flow;</div>
<div class="line"><span class="lineno">  329</span>        }</div>
<div class="line"><span class="lineno">  330</span>    }</div>
<div class="line"><span class="lineno">  331</span> </div>
<div class="line"><span class="lineno">  332</span>    cout &lt;&lt; <span class="stringliteral">&quot;The maximum number of trains that can simultaneously arrive at &quot;</span> &lt;&lt; station &lt;&lt; <span class="stringliteral">&quot; is &quot;</span> &lt;&lt; maxFlow &lt;&lt; <span class="stringliteral">&quot; trains&quot;</span> &lt;&lt; endl;</div>
<div class="line"><span class="lineno">  333</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="adf586ecc7e15be354638a771442e9fa3" name="adf586ecc7e15be354638a771442e9fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf586ecc7e15be354638a771442e9fa3">&#9670;&#160;</a></span>T3_1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Algorithms::T3_1 </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes task T3.1 of the project, which involves printing a given path, its flow, and its cost to the console. This function takes a vector of <a class="el" href="class_vertex.html">Vertex</a> pointers representing a path in a graph, and calculates the flow and cost of the path. It then prints the path to the console, along with its flow and cost. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A vector of <a class="el" href="class_vertex.html">Vertex</a> pointers representing the path in the graph. The space complexity also depends on the size of the data structures used to store the given path, as well as the results of the flow and cost calculations. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">  407</span>                                                 {</div>
<div class="line"><span class="lineno">  408</span>    <span class="keywordtype">double</span> minWeight = <a class="code hl_function" href="class_algorithms.html#a9ff92606a4424d7aacdd48ea2079dff0">getFlowAlongPath</a>(path);</div>
<div class="line"><span class="lineno">  409</span>    <span class="keywordtype">double</span> cost = <a class="code hl_function" href="class_algorithms.html#a32dc3cb0c7198774d7a1deb0cdcc28f5">getPathCost</a>(path, minWeight);</div>
<div class="line"><span class="lineno">  410</span> </div>
<div class="line"><span class="lineno">  411</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> v : path) {</div>
<div class="line"><span class="lineno">  412</span>        cout &lt;&lt; <span class="stringliteral">&quot; (&quot;</span>&lt;&lt; v-&gt;getName()  &lt;&lt;<span class="stringliteral">&quot;) &quot;</span> &lt;&lt; <span class="stringliteral">&quot; -&gt; &quot;</span>;</div>
<div class="line"><span class="lineno">  413</span>    }</div>
<div class="line"><span class="lineno">  414</span> </div>
<div class="line"><span class="lineno">  415</span>    cout &lt;&lt; <span class="stringliteral">&quot;End !&quot;</span> &lt;&lt; endl;</div>
<div class="line"><span class="lineno">  416</span> </div>
<div class="line"><span class="lineno">  417</span>    cout &lt;&lt; <span class="stringliteral">&quot;Flow of the path: &quot;</span> &lt;&lt; minWeight &lt;&lt; endl;</div>
<div class="line"><span class="lineno">  418</span> </div>
<div class="line"><span class="lineno">  419</span>    cout &lt;&lt; <span class="stringliteral">&quot;Cost of the path: &quot;</span> &lt;&lt; cost &lt;&lt; endl;</div>
<div class="line"><span class="lineno">  420</span>}</div>
<div class="ttc" id="aclass_algorithms_html_a32dc3cb0c7198774d7a1deb0cdcc28f5"><div class="ttname"><a href="class_algorithms.html#a32dc3cb0c7198774d7a1deb0cdcc28f5">Algorithms::getPathCost</a></div><div class="ttdeci">static double getPathCost(const vector&lt; Vertex * &gt; &amp;path, double minWeight)</div><div class="ttdoc">Calculates the cost of a path in a graph, taking into account the minimum weight and the type of serv...</div><div class="ttdef"><b>Definition:</b> algorithms.cpp:375</div></div>
<div class="ttc" id="aclass_algorithms_html_a9ff92606a4424d7aacdd48ea2079dff0"><div class="ttname"><a href="class_algorithms.html#a9ff92606a4424d7aacdd48ea2079dff0">Algorithms::getFlowAlongPath</a></div><div class="ttdeci">static double getFlowAlongPath(const vector&lt; Vertex * &gt; &amp;path)</div><div class="ttdoc">Computes the minimum weight along a given path in a graph.</div><div class="ttdef"><b>Definition:</b> algorithms.cpp:345</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad98b9abe79cd2f82b78c8d2125848fe7" name="ad98b9abe79cd2f82b78c8d2125848fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98b9abe79cd2f82b78c8d2125848fe7">&#9670;&#160;</a></span>T4_1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Algorithms::T4_1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a55e4ca78df85931c55cdda8dd953a45d" name="a55e4ca78df85931c55cdda8dd953a45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e4ca78df85931c55cdda8dd953a45d">&#9670;&#160;</a></span>T4_2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Algorithms::T4_2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graph.html">Graph</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the maximum number of trains that can simultaneously travel between two specific stations in a reduced graph. This function takes a <a class="el" href="class_graph.html">Graph</a> object representing a reduced graph, as well as two strings representing the source and destination stations, respectively. It calculates the maximum flow between the source and destination vertices in the reduced graph using the calculateMaxFlow function, and converts the result to the maximum number of trains that can simultaneously travel between the stations, assuming a minimum capacity per train. The result is returned as an integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reducedGraph</td><td>A reference to a <a class="el" href="class_graph.html">Graph</a> object representing the reduced graph. </td></tr>
    <tr><td class="paramname">source</td><td>A const string reference representing the name of the source station. </td></tr>
    <tr><td class="paramname">destination</td><td>A const string reference representing the name of the destination station. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer representing the maximum number of trains that can simultaneously travel between the source and destination stations in the reduced graph.</dd></dl>
<p>Executes task T4.2 of the project, which involves creating a reduced graph from a given graph. This function takes a <a class="el" href="class_graph.html">Graph</a> object, a string representing a line name, and an integer k, and uses them to create a reduced graph. It then calls the T2_3Districts and T2_3Municipalities functions to find the top districts and municipalities by flow in the reduced graph. Finally, it prints a report of the results to the console, which includes the top districts and municipalities by flow. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>A <a class="el" href="class_graph.html">Graph</a> object representing the original graph. </td></tr>
    <tr><td class="paramname">line</td><td>A string representing the name of a line in the graph. </td></tr>
    <tr><td class="paramname">k</td><td>An integer representing the threshold for the reduced graph. The space complexity also depends on the size of the data structures used to store the reduced graph, as well as the results of the T2_3Districts and T2_3Municipalities functions. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">  450</span>                                                  {</div>
<div class="line"><span class="lineno">  451</span>    <a class="code hl_class" href="class_graph.html">Graph</a> r = <a class="code hl_function" href="class_graph.html#ab90b00084ae58c0a97d1266007fe7932">Graph::createReducedGraph</a>(g, line, k);</div>
<div class="line"><span class="lineno">  452</span> </div>
<div class="line"><span class="lineno">  453</span>    vector&lt;string&gt; topDistricts = <a class="code hl_function" href="class_algorithms.html#a4c7d568629695330d874b72252251119">Algorithms::T2_3Districts</a>(&amp;r, 10);</div>
<div class="line"><span class="lineno">  454</span> </div>
<div class="line"><span class="lineno">  455</span>    vector&lt;string&gt; topMunicipality = <a class="code hl_function" href="class_algorithms.html#a88a43ec7a7c7d4aed3ccf91831233ced">Algorithms::T2_3Municipalities</a>(&amp;r, 10);</div>
<div class="line"><span class="lineno">  456</span> </div>
<div class="line"><span class="lineno">  457</span>    cout &lt;&lt; <span class="stringliteral">&quot;REPORT:&quot;</span> &lt;&lt; endl;</div>
<div class="line"><span class="lineno">  458</span> </div>
<div class="line"><span class="lineno">  459</span>    cout &lt;&lt; <span class="stringliteral">&quot;Top districts by flow:&quot;</span> &lt;&lt; endl;</div>
<div class="line"><span class="lineno">  460</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; topDistricts.size(); i++) {</div>
<div class="line"><span class="lineno">  461</span>        cout &lt;&lt; i + 1 &lt;&lt; <span class="stringliteral">&quot;. &quot;</span> &lt;&lt; topDistricts[i] &lt;&lt; endl;</div>
<div class="line"><span class="lineno">  462</span>    }</div>
<div class="line"><span class="lineno">  463</span>    cout &lt;&lt; endl;</div>
<div class="line"><span class="lineno">  464</span> </div>
<div class="line"><span class="lineno">  465</span>    cout &lt;&lt; <span class="stringliteral">&quot;Top Municipality by flow:&quot;</span> &lt;&lt; endl;</div>
<div class="line"><span class="lineno">  466</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; topMunicipality.size(); i++) {</div>
<div class="line"><span class="lineno">  467</span>        cout &lt;&lt; i + 1 &lt;&lt; <span class="stringliteral">&quot;. &quot;</span> &lt;&lt; topMunicipality[i] &lt;&lt; endl;</div>
<div class="line"><span class="lineno">  468</span>    }</div>
<div class="line"><span class="lineno">  469</span>}</div>
<div class="ttc" id="aclass_algorithms_html_a4c7d568629695330d874b72252251119"><div class="ttname"><a href="class_algorithms.html#a4c7d568629695330d874b72252251119">Algorithms::T2_3Districts</a></div><div class="ttdeci">static vector&lt; string &gt; T2_3Districts(Graph *graph, int n)</div><div class="ttdoc">Sorts the districts in a graph by their flow and returns the top n districts. This function separates...</div><div class="ttdef"><b>Definition:</b> algorithms.cpp:236</div></div>
<div class="ttc" id="aclass_algorithms_html_a88a43ec7a7c7d4aed3ccf91831233ced"><div class="ttname"><a href="class_algorithms.html#a88a43ec7a7c7d4aed3ccf91831233ced">Algorithms::T2_3Municipalities</a></div><div class="ttdeci">static vector&lt; string &gt; T2_3Municipalities(Graph *graph, int n)</div><div class="ttdoc">Separates edges in a graph by municipality and stores them into a map. This function iterates through...</div><div class="ttdef"><b>Definition:</b> algorithms.cpp:270</div></div>
<div class="ttc" id="aclass_graph_html"><div class="ttname"><a href="class_graph.html">Graph</a></div><div class="ttdef"><b>Definition:</b> newGraph.h:16</div></div>
<div class="ttc" id="aclass_graph_html_ab90b00084ae58c0a97d1266007fe7932"><div class="ttname"><a href="class_graph.html#ab90b00084ae58c0a97d1266007fe7932">Graph::createReducedGraph</a></div><div class="ttdeci">static Graph createReducedGraph(const Graph &amp;Graph, const string &amp;line, int k)</div><div class="ttdoc">Creates a reduced graph from a given graph, where the weight of edges in a specific line is reduced b...</div><div class="ttdef"><b>Definition:</b> newGraph.cpp:383</div></div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/goncalomatias/Documents/GitHub/DA1/src/<a class="el" href="algorithms_8h_source.html">algorithms.h</a></li>
<li>/Users/goncalomatias/Documents/GitHub/DA1/src/<a class="el" href="algorithms_8cpp.html">algorithms.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
