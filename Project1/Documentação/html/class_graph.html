<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DA1: Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DA1<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_graph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Graph Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="new_graph_8h_source.html">newGraph.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a902c5b3eacb66d60752525ab23297a95"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a902c5b3eacb66d60752525ab23297a95">~Graph</a> ()</td></tr>
<tr class="separator:a902c5b3eacb66d60752525ab23297a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0028a29236a09c9e056a3e7f4c1c08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#afe0028a29236a09c9e056a3e7f4c1c08">findVertex</a> (const string &amp;name) const</td></tr>
<tr class="memdesc:afe0028a29236a09c9e056a3e7f4c1c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a vertex in the graph given its name. This function iterates through the vertex set of the graph and returns the vertex with the given name, or nullptr if no such vertex exists.  <br /></td></tr>
<tr class="separator:afe0028a29236a09c9e056a3e7f4c1c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3635dfc9eda6436fe0a51765e7ea1498"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a3635dfc9eda6436fe0a51765e7ea1498">addVertex</a> (string name, string district, string municipality, string township, string line)</td></tr>
<tr class="memdesc:a3635dfc9eda6436fe0a51765e7ea1498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a vertex to the graph with the specified name, district, municipality, township, and line.  <br /></td></tr>
<tr class="separator:a3635dfc9eda6436fe0a51765e7ea1498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e12534631f32aa55bc1778da60a57e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a34e12534631f32aa55bc1778da60a57e">addEdge</a> (const string &amp;sourc, const string &amp;dest, double w, string service)</td></tr>
<tr class="memdesc:a34e12534631f32aa55bc1778da60a57e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new edge to the graph with the specified weight and service between the source and destination vertices. If either the source or destination vertex does not exist in the graph, the function returns false and the edge is not added. Otherwise, the edge is added to the adjacency list of the source vertex and the function returns true.  <br /></td></tr>
<tr class="separator:a34e12534631f32aa55bc1778da60a57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a93ac9b63627b826766336af064047"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aa2a93ac9b63627b826766336af064047">getEdge</a> (<a class="el" href="class_vertex.html">Vertex</a> *v1, <a class="el" href="class_vertex.html">Vertex</a> *v2)</td></tr>
<tr class="memdesc:aa2a93ac9b63627b826766336af064047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the edge connecting two given vertices in the graph. This function searches for an edge that connects the two given vertices in the graph. It checks all the adjacent edges of the first vertex and returns the edge that connects the first vertex to the second vertex, if such an edge exists. If there is no edge connecting the two vertices, it returns a nullptr.  <br /></td></tr>
<tr class="separator:aa2a93ac9b63627b826766336af064047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5e0517e2979c54eebdafc2a9875e8f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#abb5e0517e2979c54eebdafc2a9875e8f">getNumVertex</a> () const</td></tr>
<tr class="separator:abb5e0517e2979c54eebdafc2a9875e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56576f9c2ee0afadc4b77dcbe3acb704"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a56576f9c2ee0afadc4b77dcbe3acb704">getVertexSet</a> () const</td></tr>
<tr class="separator:a56576f9c2ee0afadc4b77dcbe3acb704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498e1372f6f65cfc080f92c3ad8ab9bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a498e1372f6f65cfc080f92c3ad8ab9bf">edmondsKarp</a> (string source, string target)</td></tr>
<tr class="memdesc:a498e1372f6f65cfc080f92c3ad8ab9bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the Edmonds-Karp algorithm to find the maximum flow in the graph from a given source to a given target vertex. This function applies the Edmonds-Karp algorithm to find the maximum flow in the graph from a given source to a given target vertex. The algorithm works by iteratively finding augmenting paths from the source to the target and updating the flow along these paths. The implementation uses breadth-first search to find the augmenting paths.  <br /></td></tr>
<tr class="separator:a498e1372f6f65cfc080f92c3ad8ab9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a3f61da41519f943da7eed5f4b1841"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a10a3f61da41519f943da7eed5f4b1841">dijkstra</a> (<a class="el" href="class_vertex.html">Vertex</a> *source, <a class="el" href="class_vertex.html">Vertex</a> *target, vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;path)</td></tr>
<tr class="separator:a10a3f61da41519f943da7eed5f4b1841"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab90b00084ae58c0a97d1266007fe7932"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ab90b00084ae58c0a97d1266007fe7932">createReducedGraph</a> (const <a class="el" href="class_graph.html">Graph</a> &amp;<a class="el" href="class_graph.html">Graph</a>, const string &amp;line, int k)</td></tr>
<tr class="memdesc:ab90b00084ae58c0a97d1266007fe7932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a reduced graph from a given graph, where the weight of edges in a specific line is reduced by a given threshold. This function takes a <a class="el" href="class_graph.html">Graph</a> object, a string representing a line name, and an integer k, and uses them to create a new <a class="el" href="class_graph.html">Graph</a> object representing a reduced version of the original graph. The weight of edges in the given line is reduced by k in the new graph. The reduced graph has the same vertices as the original graph, but potentially different edges and weights.  <br /></td></tr>
<tr class="separator:ab90b00084ae58c0a97d1266007fe7932"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa139873f6f134bbf308d33f9837b0d6b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aa139873f6f134bbf308d33f9837b0d6b">findVertexNamex</a> (const string &amp;name) const</td></tr>
<tr class="memdesc:aa139873f6f134bbf308d33f9837b0d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the minimum weight along a given path. This function iterates through each vertex in the given path and checks each adjacent edge to find the one connecting the current vertex to the next one. It returns the minimum weight found among these edges.  <br /></td></tr>
<tr class="separator:aa139873f6f134bbf308d33f9837b0d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90483b6ad02aaea613c4fd0ca7a4341"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#af90483b6ad02aaea613c4fd0ca7a4341">testAndVisit</a> (std::queue&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;q, <a class="el" href="class_edge.html">Edge</a> *e, <a class="el" href="class_vertex.html">Vertex</a> *w, double residual)</td></tr>
<tr class="memdesc:af90483b6ad02aaea613c4fd0ca7a4341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if a vertex can be visited and adds it to the BFS queue if it can be. This function checks if a vertex has already been visited and if there is still available residual capacity on the edge leading to the vertex. If both conditions are met, the vertex is marked as visited, its path is set to the given edge, and it is added to the BFS queue.  <br /></td></tr>
<tr class="separator:af90483b6ad02aaea613c4fd0ca7a4341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5af5d9fba5bac37ed469fa3d8e5f1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a3b5af5d9fba5bac37ed469fa3d8e5f1b">findAugmentingPath</a> (<a class="el" href="class_vertex.html">Vertex</a> *s, <a class="el" href="class_vertex.html">Vertex</a> *t)</td></tr>
<tr class="memdesc:a3b5af5d9fba5bac37ed469fa3d8e5f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an augmenting path between two vertices in the graph using a breadth-first search algorithm. The function searches for an augmenting path between two vertices using a breadth-first search algorithm starting at the source vertex s and stopping when it reaches the target vertex t. If an augmenting path is found, the function returns true and stores the path in the "path" attribute of the vertices. Otherwise, it returns false and the "path" attribute of the vertices is set to nullptr.  <br /></td></tr>
<tr class="separator:a3b5af5d9fba5bac37ed469fa3d8e5f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83c8bcf6feb001881f09c5b52f6576f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aa83c8bcf6feb001881f09c5b52f6576f">findMinResidualAlongPath</a> (<a class="el" href="class_vertex.html">Vertex</a> *s, <a class="el" href="class_vertex.html">Vertex</a> *t)</td></tr>
<tr class="memdesc:aa83c8bcf6feb001881f09c5b52f6576f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the minimum residual capacity along a path from s to t. This function takes two vertex pointers, s and t, representing the start and end vertices of a path, respectively. It then traverses the path backwards from t to s, calculating the minimum residual capacity along the path as it goes.  <br /></td></tr>
<tr class="separator:aa83c8bcf6feb001881f09c5b52f6576f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4cb3533098748b7e67bb8c941a59b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a1e4cb3533098748b7e67bb8c941a59b3">augmentFlowAlongPath</a> (<a class="el" href="class_vertex.html">Vertex</a> *s, <a class="el" href="class_vertex.html">Vertex</a> *t, double f)</td></tr>
<tr class="memdesc:a1e4cb3533098748b7e67bb8c941a59b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether a vertex can be visited and pushed to a queue in the context of an algorithm.  <br /></td></tr>
<tr class="separator:a1e4cb3533098748b7e67bb8c941a59b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a828b7f04ee093d89fc35aef9b43b2d2e"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a828b7f04ee093d89fc35aef9b43b2d2e">vertexSet</a></td></tr>
<tr class="separator:a828b7f04ee093d89fc35aef9b43b2d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e61864da69191c1896a25a708d1a02d"><td class="memItemLeft" align="right" valign="top">double **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a9e61864da69191c1896a25a708d1a02d">distMatrix</a> = nullptr</td></tr>
<tr class="separator:a9e61864da69191c1896a25a708d1a02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae09699c3616af3ebfcb1eb045f2b62"><td class="memItemLeft" align="right" valign="top">int **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a3ae09699c3616af3ebfcb1eb045f2b62">pathMatrix</a> = nullptr</td></tr>
<tr class="separator:a3ae09699c3616af3ebfcb1eb045f2b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a902c5b3eacb66d60752525ab23297a95" name="a902c5b3eacb66d60752525ab23297a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a902c5b3eacb66d60752525ab23297a95">&#9670;&#160;</a></span>~Graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Graph::~Graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  408</span>              {</div>
<div class="line"><span class="lineno">  409</span>    <a class="code hl_function" href="new_graph_8h.html#ad56527992afe31a371065e795da57d25">deleteMatrix</a>(<a class="code hl_variable" href="class_graph.html#a9e61864da69191c1896a25a708d1a02d">distMatrix</a>, <a class="code hl_variable" href="class_graph.html#a828b7f04ee093d89fc35aef9b43b2d2e">vertexSet</a>.size());</div>
<div class="line"><span class="lineno">  410</span>    <a class="code hl_function" href="new_graph_8h.html#ad56527992afe31a371065e795da57d25">deleteMatrix</a>(<a class="code hl_variable" href="class_graph.html#a3ae09699c3616af3ebfcb1eb045f2b62">pathMatrix</a>, <a class="code hl_variable" href="class_graph.html#a828b7f04ee093d89fc35aef9b43b2d2e">vertexSet</a>.size());</div>
<div class="line"><span class="lineno">  411</span>}</div>
<div class="ttc" id="aclass_graph_html_a3ae09699c3616af3ebfcb1eb045f2b62"><div class="ttname"><a href="class_graph.html#a3ae09699c3616af3ebfcb1eb045f2b62">Graph::pathMatrix</a></div><div class="ttdeci">int ** pathMatrix</div><div class="ttdef"><b>Definition:</b> newGraph.h:52</div></div>
<div class="ttc" id="aclass_graph_html_a828b7f04ee093d89fc35aef9b43b2d2e"><div class="ttname"><a href="class_graph.html#a828b7f04ee093d89fc35aef9b43b2d2e">Graph::vertexSet</a></div><div class="ttdeci">vector&lt; Vertex * &gt; vertexSet</div><div class="ttdef"><b>Definition:</b> newGraph.h:49</div></div>
<div class="ttc" id="aclass_graph_html_a9e61864da69191c1896a25a708d1a02d"><div class="ttname"><a href="class_graph.html#a9e61864da69191c1896a25a708d1a02d">Graph::distMatrix</a></div><div class="ttdeci">double ** distMatrix</div><div class="ttdef"><b>Definition:</b> newGraph.h:51</div></div>
<div class="ttc" id="anew_graph_8h_html_ad56527992afe31a371065e795da57d25"><div class="ttname"><a href="new_graph_8h.html#ad56527992afe31a371065e795da57d25">deleteMatrix</a></div><div class="ttdeci">void deleteMatrix(int **m, int n)</div><div class="ttdoc">Deletes a 2D integer array. This function deletes a 2D integer array by iterating through each row an...</div><div class="ttdef"><b>Definition:</b> newGraph.cpp:136</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a34e12534631f32aa55bc1778da60a57e" name="a34e12534631f32aa55bc1778da60a57e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e12534631f32aa55bc1778da60a57e">&#9670;&#160;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::addEdge </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>sourc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>service</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new edge to the graph with the specified weight and service between the source and destination vertices. If either the source or destination vertex does not exist in the graph, the function returns false and the edge is not added. Otherwise, the edge is added to the adjacency list of the source vertex and the function returns true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourc</td><td>Name of the source vertex. </td></tr>
    <tr><td class="paramname">dest</td><td>Name of the destination vertex. </td></tr>
    <tr><td class="paramname">w</td><td>Weight of the edge. </td></tr>
    <tr><td class="paramname">service</td><td>Name of the service associated with the edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the edge was added successfully, false otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function assumes that the graph is undirected, so it adds the same edge in both directions (i.e., from sourc to dest and from dest to sourc). </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">   96</span>                                                                                     {</div>
<div class="line"><span class="lineno">   97</span>    <span class="keyword">auto</span> v1 = <a class="code hl_function" href="class_graph.html#afe0028a29236a09c9e056a3e7f4c1c08">findVertex</a>(sourc);</div>
<div class="line"><span class="lineno">   98</span>    <span class="keyword">auto</span> v2 = <a class="code hl_function" href="class_graph.html#afe0028a29236a09c9e056a3e7f4c1c08">findVertex</a>(dest);</div>
<div class="line"><span class="lineno">   99</span>    <span class="keywordflow">if</span> (v1 == <span class="keyword">nullptr</span> || v2 == <span class="keyword">nullptr</span>)</div>
<div class="line"><span class="lineno">  100</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  101</span>    v1-&gt;addEdge(v2, w, service);</div>
<div class="line"><span class="lineno">  102</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  103</span>}</div>
<div class="ttc" id="aclass_graph_html_afe0028a29236a09c9e056a3e7f4c1c08"><div class="ttname"><a href="class_graph.html#afe0028a29236a09c9e056a3e7f4c1c08">Graph::findVertex</a></div><div class="ttdeci">Vertex * findVertex(const string &amp;name) const</div><div class="ttdoc">Finds a vertex in the graph given its name. This function iterates through the vertex set of the grap...</div><div class="ttdef"><b>Definition:</b> newGraph.cpp:27</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3635dfc9eda6436fe0a51765e7ea1498" name="a3635dfc9eda6436fe0a51765e7ea1498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3635dfc9eda6436fe0a51765e7ea1498">&#9670;&#160;</a></span>addVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::addVertex </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>district</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>municipality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>township</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a vertex to the graph with the specified name, district, municipality, township, and line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the vertex to add. </td></tr>
    <tr><td class="paramname">district</td><td>District of the vertex to add. </td></tr>
    <tr><td class="paramname">municipality</td><td>Municipality of the vertex to add. </td></tr>
    <tr><td class="paramname">township</td><td>Township of the vertex to add. </td></tr>
    <tr><td class="paramname">line</td><td>Line of the vertex to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the vertex was successfully added, false otherwise. This function creates a new vertex with the specified parameters and adds it to the graph's vertex set. If a vertex with the same name already exists in the graph, the function returns false and does not add the vertex. Time complexity: O(n), where n is the number of vertices in the graph. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">   71</span>                                                                                                     {</div>
<div class="line"><span class="lineno">   72</span>    <span class="keywordflow">if</span> (<a class="code hl_function" href="class_graph.html#afe0028a29236a09c9e056a3e7f4c1c08">findVertex</a>(name) != <span class="keyword">nullptr</span>)</div>
<div class="line"><span class="lineno">   73</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">   74</span>    <a class="code hl_variable" href="class_graph.html#a828b7f04ee093d89fc35aef9b43b2d2e">vertexSet</a>.push_back(<span class="keyword">new</span> <a class="code hl_class" href="class_vertex.html">Vertex</a>(name, district, municipality, township, line));</div>
<div class="line"><span class="lineno">   75</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">   76</span>}</div>
<div class="ttc" id="aclass_vertex_html"><div class="ttname"><a href="class_vertex.html">Vertex</a></div><div class="ttdef"><b>Definition:</b> vertexEdge.h:18</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1e4cb3533098748b7e67bb8c941a59b3" name="a1e4cb3533098748b7e67bb8c941a59b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4cb3533098748b7e67bb8c941a59b3">&#9670;&#160;</a></span>augmentFlowAlongPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::augmentFlowAlongPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether a vertex can be visited and pushed to a queue in the context of an algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>A reference to a queue of vertices. </td></tr>
    <tr><td class="paramname">e</td><td>A pointer to the edge connecting the vertices. </td></tr>
    <tr><td class="paramname">w</td><td>A pointer to the destination vertex. </td></tr>
    <tr><td class="paramname">residual</td><td>The residual capacity of the edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. This function checks whether a vertex has not been visited yet and has a positive residual capacity before setting the vertex's visited status, path and pushing it into a queue. Time complexity: O(1) </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  268</span>                                                               {</div>
<div class="line"><span class="lineno">  269</span>    <span class="keyword">auto</span> v = t;</div>
<div class="line"><span class="lineno">  270</span>    <span class="keywordflow">while</span> (v != s) {</div>
<div class="line"><span class="lineno">  271</span>        <span class="keyword">auto</span> e = v-&gt;<a class="code hl_function" href="class_vertex.html#a6e120e57da6af94892fae44e05868794">getPath</a>();</div>
<div class="line"><span class="lineno">  272</span>        <span class="keywordflow">if</span> (e-&gt;getDest() == v) {</div>
<div class="line"><span class="lineno">  273</span>            e-&gt;<a class="code hl_function" href="class_edge.html#a788cfe1f98772af4e7bbfe6310d0ccaa">setFlow</a>(e-&gt;getFlow() + f); <span class="comment">// add f to current flow</span></div>
<div class="line"><span class="lineno">  274</span>        } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  275</span>            e-&gt;setFlow(e-&gt;getFlow() - f); <span class="comment">// subtract f from current flow</span></div>
<div class="line"><span class="lineno">  276</span>        }</div>
<div class="line"><span class="lineno">  277</span>        v = e-&gt;getOrig();</div>
<div class="line"><span class="lineno">  278</span>    }</div>
<div class="line"><span class="lineno">  279</span>}</div>
<div class="ttc" id="aclass_edge_html_a788cfe1f98772af4e7bbfe6310d0ccaa"><div class="ttname"><a href="class_edge.html#a788cfe1f98772af4e7bbfe6310d0ccaa">Edge::setFlow</a></div><div class="ttdeci">void setFlow(double flow)</div><div class="ttdef"><b>Definition:</b> vertexEdge.cpp:192</div></div>
<div class="ttc" id="aclass_vertex_html_a6e120e57da6af94892fae44e05868794"><div class="ttname"><a href="class_vertex.html#a6e120e57da6af94892fae44e05868794">Vertex::getPath</a></div><div class="ttdeci">Edge * getPath() const</div><div class="ttdef"><b>Definition:</b> vertexEdge.cpp:104</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab90b00084ae58c0a97d1266007fe7932" name="ab90b00084ae58c0a97d1266007fe7932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90b00084ae58c0a97d1266007fe7932">&#9670;&#160;</a></span>createReducedGraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_graph.html">Graph</a> Graph::createReducedGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a reduced graph from a given graph, where the weight of edges in a specific line is reduced by a given threshold. This function takes a <a class="el" href="class_graph.html">Graph</a> object, a string representing a line name, and an integer k, and uses them to create a new <a class="el" href="class_graph.html">Graph</a> object representing a reduced version of the original graph. The weight of edges in the given line is reduced by k in the new graph. The reduced graph has the same vertices as the original graph, but potentially different edges and weights. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>A const <a class="el" href="class_graph.html">Graph</a> reference to the original graph object. </td></tr>
    <tr><td class="paramname">line</td><td>A const string reference representing the name of a line in the graph. </td></tr>
    <tr><td class="paramname">k</td><td>An integer representing the threshold for reducing the weight of edges in the given line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_graph.html">Graph</a> object representing the reduced version of the original graph. The space complexity is also O(V * E), since the reduced graph may have the same number of vertices and edges as the given graph. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  383</span>                                                                             {</div>
<div class="line"><span class="lineno">  384</span>    <a class="code hl_class" href="class_graph.html">Graph</a> reducedGraph;</div>
<div class="line"><span class="lineno">  385</span> </div>
<div class="line"><span class="lineno">  386</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; vertex : graph.<a class="code hl_function" href="class_graph.html#a56576f9c2ee0afadc4b77dcbe3acb704">getVertexSet</a>()) {</div>
<div class="line"><span class="lineno">  387</span>        reducedGraph.<a class="code hl_function" href="class_graph.html#a3635dfc9eda6436fe0a51765e7ea1498">addVertex</a>(vertex-&gt;getName(), vertex-&gt;getDistrict(), vertex-&gt;getMunicipality(),</div>
<div class="line"><span class="lineno">  388</span>                               vertex-&gt;getTownship(), vertex-&gt;getLine());</div>
<div class="line"><span class="lineno">  389</span>    }</div>
<div class="line"><span class="lineno">  390</span> </div>
<div class="line"><span class="lineno">  391</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; vertex : graph.<a class="code hl_function" href="class_graph.html#a56576f9c2ee0afadc4b77dcbe3acb704">getVertexSet</a>()) {</div>
<div class="line"><span class="lineno">  392</span>        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; edge : vertex-&gt;getAdj()) {</div>
<div class="line"><span class="lineno">  393</span>            <a class="code hl_class" href="class_vertex.html">Vertex</a>* adjVertex = edge-&gt;getDest();</div>
<div class="line"><span class="lineno">  394</span>            <span class="keywordflow">if</span> (vertex-&gt;getLine() == line &amp;&amp; adjVertex-&gt;<a class="code hl_function" href="class_vertex.html#ad071b1a9398fc94bf5ec22e3e78c1342">getLine</a>() == line) {</div>
<div class="line"><span class="lineno">  395</span>                reducedGraph.<a class="code hl_function" href="class_graph.html#a34e12534631f32aa55bc1778da60a57e">addEdge</a>(vertex-&gt;getName(), adjVertex-&gt;<a class="code hl_function" href="class_vertex.html#a9d1db1789299fd14088a7f4bc3c8e194">getName</a>(), edge-&gt;getWeight() - k, edge-&gt;getService());</div>
<div class="line"><span class="lineno">  396</span>            }</div>
<div class="line"><span class="lineno">  397</span>            <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  398</span>                reducedGraph.<a class="code hl_function" href="class_graph.html#a34e12534631f32aa55bc1778da60a57e">addEdge</a>(vertex-&gt;getName(), adjVertex-&gt;<a class="code hl_function" href="class_vertex.html#a9d1db1789299fd14088a7f4bc3c8e194">getName</a>(), edge-&gt;getWeight(), edge-&gt;getService());</div>
<div class="line"><span class="lineno">  399</span>            }</div>
<div class="line"><span class="lineno">  400</span>        }</div>
<div class="line"><span class="lineno">  401</span>    }</div>
<div class="line"><span class="lineno">  402</span> </div>
<div class="line"><span class="lineno">  403</span>    <span class="keywordflow">return</span> reducedGraph;</div>
<div class="line"><span class="lineno">  404</span>}</div>
<div class="ttc" id="aclass_graph_html"><div class="ttname"><a href="class_graph.html">Graph</a></div><div class="ttdef"><b>Definition:</b> newGraph.h:16</div></div>
<div class="ttc" id="aclass_graph_html_a34e12534631f32aa55bc1778da60a57e"><div class="ttname"><a href="class_graph.html#a34e12534631f32aa55bc1778da60a57e">Graph::addEdge</a></div><div class="ttdeci">bool addEdge(const string &amp;sourc, const string &amp;dest, double w, string service)</div><div class="ttdoc">Adds a new edge to the graph with the specified weight and service between the source and destination...</div><div class="ttdef"><b>Definition:</b> newGraph.cpp:96</div></div>
<div class="ttc" id="aclass_graph_html_a3635dfc9eda6436fe0a51765e7ea1498"><div class="ttname"><a href="class_graph.html#a3635dfc9eda6436fe0a51765e7ea1498">Graph::addVertex</a></div><div class="ttdeci">bool addVertex(string name, string district, string municipality, string township, string line)</div><div class="ttdoc">Adds a vertex to the graph with the specified name, district, municipality, township,...</div><div class="ttdef"><b>Definition:</b> newGraph.cpp:71</div></div>
<div class="ttc" id="aclass_graph_html_a56576f9c2ee0afadc4b77dcbe3acb704"><div class="ttname"><a href="class_graph.html#a56576f9c2ee0afadc4b77dcbe3acb704">Graph::getVertexSet</a></div><div class="ttdeci">vector&lt; Vertex * &gt; getVertexSet() const</div><div class="ttdef"><b>Definition:</b> newGraph.cpp:11</div></div>
<div class="ttc" id="aclass_vertex_html_a9d1db1789299fd14088a7f4bc3c8e194"><div class="ttname"><a href="class_vertex.html#a9d1db1789299fd14088a7f4bc3c8e194">Vertex::getName</a></div><div class="ttdeci">string getName() const</div><div class="ttdef"><b>Definition:</b> vertexEdge.cpp:72</div></div>
<div class="ttc" id="aclass_vertex_html_ad071b1a9398fc94bf5ec22e3e78c1342"><div class="ttname"><a href="class_vertex.html#ad071b1a9398fc94bf5ec22e3e78c1342">Vertex::getLine</a></div><div class="ttdeci">string getLine() const</div><div class="ttdef"><b>Definition:</b> vertexEdge.cpp:88</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a10a3f61da41519f943da7eed5f4b1841" name="a10a3f61da41519f943da7eed5f4b1841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a3f61da41519f943da7eed5f4b1841">&#9670;&#160;</a></span>dijkstra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::dijkstra </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dijkstra's algorithm for finding the shortest path between two vertices in the graph. This function uses Dijkstra's algorithm to calculate the shortest path between a source and a target vertex in the graph. The result is stored in the path vector, which contains the vertices of the path in order from the source to the target. The function assumes that all edges in the graph have non-negative weights. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source vertex. </td></tr>
    <tr><td class="paramname">target</td><td>The target vertex. </td></tr>
    <tr><td class="paramname">path</td><td>A reference to a vector of vertices that will store the resulting path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void @complexity O(E*log(V)), where E is the number of edges and V is the number of vertices in the graph. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  327</span>                                                                          {</div>
<div class="line"><span class="lineno">  328</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> v : <a class="code hl_variable" href="class_graph.html#a828b7f04ee093d89fc35aef9b43b2d2e">vertexSet</a>) {</div>
<div class="line"><span class="lineno">  329</span>        v-&gt;setDist(<a class="code hl_define" href="vertex_edge_8h.html#a12c2040f25d8e3a7b9e1c2024c618cb6">INF</a>);</div>
<div class="line"><span class="lineno">  330</span>        v-&gt;setPath(<span class="keyword">nullptr</span>);</div>
<div class="line"><span class="lineno">  331</span>    }</div>
<div class="line"><span class="lineno">  332</span>    source-&gt;<a class="code hl_function" href="class_vertex.html#a6939bef79bfe5fe5bf77d9fd1bd70085">setDist</a>(0);</div>
<div class="line"><span class="lineno">  333</span> </div>
<div class="line"><span class="lineno">  334</span>    priority_queue&lt;pair&lt;double, Vertex*&gt;, vector&lt;pair&lt;double, Vertex*&gt;&gt;, greater&lt;&gt;&gt; pq;</div>
<div class="line"><span class="lineno">  335</span>    pq.emplace(0, source);</div>
<div class="line"><span class="lineno">  336</span> </div>
<div class="line"><span class="lineno">  337</span>    <span class="keywordflow">while</span> (!pq.empty()) {</div>
<div class="line"><span class="lineno">  338</span>        <a class="code hl_class" href="class_vertex.html">Vertex</a> *v = pq.top().second;</div>
<div class="line"><span class="lineno">  339</span>        pq.pop();</div>
<div class="line"><span class="lineno">  340</span> </div>
<div class="line"><span class="lineno">  341</span>        <span class="keywordflow">if</span> (v == target) {</div>
<div class="line"><span class="lineno">  342</span>            <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  343</span>        }</div>
<div class="line"><span class="lineno">  344</span> </div>
<div class="line"><span class="lineno">  345</span> </div>
<div class="line"><span class="lineno">  346</span>        <span class="keywordflow">if</span> (v-&gt;<a class="code hl_function" href="class_vertex.html#aa4bd82105b85ee53a917391f4811cd8a">isVisited</a>()) {</div>
<div class="line"><span class="lineno">  347</span>            <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  348</span>        }</div>
<div class="line"><span class="lineno">  349</span>        v-&gt;<a class="code hl_function" href="class_vertex.html#a15eeabbbb6d517af746ae137c6d5b595">setVisited</a>(<span class="keyword">true</span>);</div>
<div class="line"><span class="lineno">  350</span> </div>
<div class="line"><span class="lineno">  351</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : v-&gt;<a class="code hl_function" href="class_vertex.html#a9858f2aa388d2bfb49d9df8f4504b5a0">getAdj</a>()) {</div>
<div class="line"><span class="lineno">  352</span>            <a class="code hl_class" href="class_vertex.html">Vertex</a> *w = e-&gt;getDest();</div>
<div class="line"><span class="lineno">  353</span>            <span class="keywordtype">double</span> weight = e-&gt;getWeight();</div>
<div class="line"><span class="lineno">  354</span> </div>
<div class="line"><span class="lineno">  355</span>            <span class="keywordflow">if</span> (w-&gt;<a class="code hl_function" href="class_vertex.html#aa36ca926de23a6e7283be42e2930957c">getDist</a>() &gt; v-&gt;<a class="code hl_function" href="class_vertex.html#aa36ca926de23a6e7283be42e2930957c">getDist</a>() + weight) {</div>
<div class="line"><span class="lineno">  356</span>                w-&gt;<a class="code hl_function" href="class_vertex.html#a6939bef79bfe5fe5bf77d9fd1bd70085">setDist</a>(v-&gt;<a class="code hl_function" href="class_vertex.html#aa36ca926de23a6e7283be42e2930957c">getDist</a>() + weight);</div>
<div class="line"><span class="lineno">  357</span>                w-&gt;<a class="code hl_function" href="class_vertex.html#abe4bc30005eec65e775d0cd51f456460">setPath</a>(e);</div>
<div class="line"><span class="lineno">  358</span> </div>
<div class="line"><span class="lineno">  359</span>                pq.emplace(w-&gt;<a class="code hl_function" href="class_vertex.html#aa36ca926de23a6e7283be42e2930957c">getDist</a>(), w);</div>
<div class="line"><span class="lineno">  360</span>            }</div>
<div class="line"><span class="lineno">  361</span>        }</div>
<div class="line"><span class="lineno">  362</span>    }</div>
<div class="line"><span class="lineno">  363</span> </div>
<div class="line"><span class="lineno">  364</span>    path.clear();</div>
<div class="line"><span class="lineno">  365</span>    <span class="keywordflow">for</span> (<a class="code hl_class" href="class_vertex.html">Vertex</a> *v = target; v != <span class="keyword">nullptr</span>; v = v-&gt;<a class="code hl_function" href="class_vertex.html#a6e120e57da6af94892fae44e05868794">getPath</a>() ? v-&gt;<a class="code hl_function" href="class_vertex.html#a6e120e57da6af94892fae44e05868794">getPath</a>()-&gt;<a class="code hl_function" href="class_edge.html#a6e8b08e91c0694b40edff0432fb612eb">getOrig</a>() : <span class="keyword">nullptr</span>) {</div>
<div class="line"><span class="lineno">  366</span>        path.push_back(v);</div>
<div class="line"><span class="lineno">  367</span>    }</div>
<div class="line"><span class="lineno">  368</span>    reverse(path.begin(), path.end());</div>
<div class="line"><span class="lineno">  369</span>}</div>
<div class="ttc" id="aclass_edge_html_a6e8b08e91c0694b40edff0432fb612eb"><div class="ttname"><a href="class_edge.html#a6e8b08e91c0694b40edff0432fb612eb">Edge::getOrig</a></div><div class="ttdeci">Vertex * getOrig() const</div><div class="ttdef"><b>Definition:</b> vertexEdge.cpp:167</div></div>
<div class="ttc" id="aclass_vertex_html_a15eeabbbb6d517af746ae137c6d5b595"><div class="ttname"><a href="class_vertex.html#a15eeabbbb6d517af746ae137c6d5b595">Vertex::setVisited</a></div><div class="ttdeci">void setVisited(bool visited)</div><div class="ttdef"><b>Definition:</b> vertexEdge.cpp:134</div></div>
<div class="ttc" id="aclass_vertex_html_a6939bef79bfe5fe5bf77d9fd1bd70085"><div class="ttname"><a href="class_vertex.html#a6939bef79bfe5fe5bf77d9fd1bd70085">Vertex::setDist</a></div><div class="ttdeci">void setDist(double dist)</div><div class="ttdef"><b>Definition:</b> vertexEdge.cpp:139</div></div>
<div class="ttc" id="aclass_vertex_html_a9858f2aa388d2bfb49d9df8f4504b5a0"><div class="ttname"><a href="class_vertex.html#a9858f2aa388d2bfb49d9df8f4504b5a0">Vertex::getAdj</a></div><div class="ttdeci">vector&lt; Edge * &gt; getAdj() const</div><div class="ttdef"><b>Definition:</b> vertexEdge.cpp:92</div></div>
<div class="ttc" id="aclass_vertex_html_aa36ca926de23a6e7283be42e2930957c"><div class="ttname"><a href="class_vertex.html#aa36ca926de23a6e7283be42e2930957c">Vertex::getDist</a></div><div class="ttdeci">double getDist() const</div><div class="ttdef"><b>Definition:</b> vertexEdge.cpp:100</div></div>
<div class="ttc" id="aclass_vertex_html_aa4bd82105b85ee53a917391f4811cd8a"><div class="ttname"><a href="class_vertex.html#aa4bd82105b85ee53a917391f4811cd8a">Vertex::isVisited</a></div><div class="ttdeci">bool isVisited() const</div><div class="ttdef"><b>Definition:</b> vertexEdge.cpp:96</div></div>
<div class="ttc" id="aclass_vertex_html_abe4bc30005eec65e775d0cd51f456460"><div class="ttname"><a href="class_vertex.html#abe4bc30005eec65e775d0cd51f456460">Vertex::setPath</a></div><div class="ttdeci">void setPath(Edge *path)</div><div class="ttdef"><b>Definition:</b> vertexEdge.cpp:143</div></div>
<div class="ttc" id="avertex_edge_8h_html_a12c2040f25d8e3a7b9e1c2024c618cb6"><div class="ttname"><a href="vertex_edge_8h.html#a12c2040f25d8e3a7b9e1c2024c618cb6">INF</a></div><div class="ttdeci">#define INF</div><div class="ttdef"><b>Definition:</b> vertexEdge.h:14</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a498e1372f6f65cfc080f92c3ad8ab9bf" name="a498e1372f6f65cfc080f92c3ad8ab9bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498e1372f6f65cfc080f92c3ad8ab9bf">&#9670;&#160;</a></span>edmondsKarp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::edmondsKarp </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the Edmonds-Karp algorithm to find the maximum flow in the graph from a given source to a given target vertex. This function applies the Edmonds-Karp algorithm to find the maximum flow in the graph from a given source to a given target vertex. The algorithm works by iteratively finding augmenting paths from the source to the target and updating the flow along these paths. The implementation uses breadth-first search to find the augmenting paths. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The name of the source vertex. </td></tr>
    <tr><td class="paramname">target</td><td>The name of the target vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the source or target vertex is not found in the graph or if the source and target vertices are the same. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function resets the flow values of all edges in the graph to zero before starting the algorithm. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_graph.html#a3b5af5d9fba5bac37ed469fa3d8e5f1b" title="Finds an augmenting path between two vertices in the graph using a breadth-first search algorithm....">findAugmentingPath(Vertex *s, Vertex *t)</a> </dd>
<dd>
<a class="el" href="class_graph.html#aa83c8bcf6feb001881f09c5b52f6576f" title="Finds the minimum residual capacity along a path from s to t. This function takes two vertex pointers...">findMinResidualAlongPath(Vertex *s, Vertex *t)</a> </dd>
<dd>
<a class="el" href="class_graph.html#a1e4cb3533098748b7e67bb8c941a59b3" title="Test whether a vertex can be visited and pushed to a queue in the context of an algorithm.">augmentFlowAlongPath(Vertex *s, Vertex *t, double f)</a> @complexity The time complexity of this algorithm is O(E^2 * V), where E is the number of edges in the graph and V is the number of vertices. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  296</span>                                                    {</div>
<div class="line"><span class="lineno">  297</span>    <a class="code hl_class" href="class_vertex.html">Vertex</a> *s = <a class="code hl_function" href="class_graph.html#afe0028a29236a09c9e056a3e7f4c1c08">findVertex</a>(source);</div>
<div class="line"><span class="lineno">  298</span>    <a class="code hl_class" href="class_vertex.html">Vertex</a> *t = <a class="code hl_function" href="class_graph.html#afe0028a29236a09c9e056a3e7f4c1c08">findVertex</a>(target);</div>
<div class="line"><span class="lineno">  299</span>    <span class="keywordflow">if</span> (s == <span class="keyword">nullptr</span> || t == <span class="keyword">nullptr</span> || s == t)</div>
<div class="line"><span class="lineno">  300</span>        <span class="keywordflow">throw</span> std::logic_error(<span class="stringliteral">&quot;Invalid source and/or target vertex&quot;</span>);</div>
<div class="line"><span class="lineno">  301</span> </div>
<div class="line"><span class="lineno">  302</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> v : <a class="code hl_variable" href="class_graph.html#a828b7f04ee093d89fc35aef9b43b2d2e">vertexSet</a>) {</div>
<div class="line"><span class="lineno">  303</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : v-&gt;getAdj()) {</div>
<div class="line"><span class="lineno">  304</span>            e-&gt;setFlow(0);</div>
<div class="line"><span class="lineno">  305</span>        }</div>
<div class="line"><span class="lineno">  306</span>    }</div>
<div class="line"><span class="lineno">  307</span>    <span class="keywordflow">while</span> (<a class="code hl_function" href="class_graph.html#a3b5af5d9fba5bac37ed469fa3d8e5f1b">findAugmentingPath</a>(s, t)) {</div>
<div class="line"><span class="lineno">  308</span>        <span class="keywordtype">double</span> f = <a class="code hl_function" href="class_graph.html#aa83c8bcf6feb001881f09c5b52f6576f">findMinResidualAlongPath</a>(s, t);</div>
<div class="line"><span class="lineno">  309</span>        <a class="code hl_function" href="class_graph.html#a1e4cb3533098748b7e67bb8c941a59b3">augmentFlowAlongPath</a>(s, t, f);</div>
<div class="line"><span class="lineno">  310</span>    }</div>
<div class="line"><span class="lineno">  311</span>}</div>
<div class="ttc" id="aclass_graph_html_a1e4cb3533098748b7e67bb8c941a59b3"><div class="ttname"><a href="class_graph.html#a1e4cb3533098748b7e67bb8c941a59b3">Graph::augmentFlowAlongPath</a></div><div class="ttdeci">void augmentFlowAlongPath(Vertex *s, Vertex *t, double f)</div><div class="ttdoc">Test whether a vertex can be visited and pushed to a queue in the context of an algorithm.</div><div class="ttdef"><b>Definition:</b> newGraph.cpp:268</div></div>
<div class="ttc" id="aclass_graph_html_a3b5af5d9fba5bac37ed469fa3d8e5f1b"><div class="ttname"><a href="class_graph.html#a3b5af5d9fba5bac37ed469fa3d8e5f1b">Graph::findAugmentingPath</a></div><div class="ttdeci">bool findAugmentingPath(Vertex *s, Vertex *t)</div><div class="ttdoc">Finds an augmenting path between two vertices in the graph using a breadth-first search algorithm....</div><div class="ttdef"><b>Definition:</b> newGraph.cpp:201</div></div>
<div class="ttc" id="aclass_graph_html_aa83c8bcf6feb001881f09c5b52f6576f"><div class="ttname"><a href="class_graph.html#aa83c8bcf6feb001881f09c5b52f6576f">Graph::findMinResidualAlongPath</a></div><div class="ttdeci">double findMinResidualAlongPath(Vertex *s, Vertex *t)</div><div class="ttdoc">Finds the minimum residual capacity along a path from s to t. This function takes two vertex pointers...</div><div class="ttdef"><b>Definition:</b> newGraph.cpp:243</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3b5af5d9fba5bac37ed469fa3d8e5f1b" name="a3b5af5d9fba5bac37ed469fa3d8e5f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5af5d9fba5bac37ed469fa3d8e5f1b">&#9670;&#160;</a></span>findAugmentingPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::findAugmentingPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an augmenting path between two vertices in the graph using a breadth-first search algorithm. The function searches for an augmenting path between two vertices using a breadth-first search algorithm starting at the source vertex s and stopping when it reaches the target vertex t. If an augmenting path is found, the function returns true and stores the path in the "path" attribute of the vertices. Otherwise, it returns false and the "path" attribute of the vertices is set to nullptr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Pointer to the source vertex. </td></tr>
    <tr><td class="paramname">t</td><td>Pointer to the target vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if an augmenting path was found, false otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function uses a queue data structure to implement the breadth-first search algorithm, and it sets the "visited" and "path" attributes of the vertices. The time complexity of the function is O(E), where E is the number of edges in the graph, because it visits each edge at most twice (once in each direction). The space complexity of the function is also O(E), because it uses a queue to store the vertices to be visited. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  201</span>                                                   {</div>
<div class="line"><span class="lineno">  202</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> v : <a class="code hl_variable" href="class_graph.html#a828b7f04ee093d89fc35aef9b43b2d2e">vertexSet</a>) {</div>
<div class="line"><span class="lineno">  203</span>        v-&gt;setVisited(<span class="keyword">false</span>);</div>
<div class="line"><span class="lineno">  204</span>        v-&gt;setPath(<span class="keyword">nullptr</span>);</div>
<div class="line"><span class="lineno">  205</span>    }</div>
<div class="line"><span class="lineno">  206</span>    s-&gt;<a class="code hl_function" href="class_vertex.html#a15eeabbbb6d517af746ae137c6d5b595">setVisited</a>(<span class="keyword">true</span>);</div>
<div class="line"><span class="lineno">  207</span>    queue&lt;Vertex *&gt; q;</div>
<div class="line"><span class="lineno">  208</span>    q.push(s);</div>
<div class="line"><span class="lineno">  209</span>    <span class="keywordflow">while</span> (!q.empty() &amp;&amp; !t-&gt;<a class="code hl_function" href="class_vertex.html#aa4bd82105b85ee53a917391f4811cd8a">isVisited</a>()) {</div>
<div class="line"><span class="lineno">  210</span>        <span class="keyword">auto</span> v = q.front();</div>
<div class="line"><span class="lineno">  211</span>        q.pop();</div>
<div class="line"><span class="lineno">  212</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : v-&gt;getAdj()) {</div>
<div class="line"><span class="lineno">  213</span>            <span class="keyword">auto</span> w = e-&gt;getDest();</div>
<div class="line"><span class="lineno">  214</span>            <span class="keywordflow">if</span> (!w-&gt;isVisited() &amp;&amp; e-&gt;getWeight() - e-&gt;getFlow() &gt; 0) {</div>
<div class="line"><span class="lineno">  215</span>                w-&gt;setVisited(<span class="keyword">true</span>);</div>
<div class="line"><span class="lineno">  216</span>                w-&gt;setPath(e);</div>
<div class="line"><span class="lineno">  217</span>                q.push(w);</div>
<div class="line"><span class="lineno">  218</span>            }</div>
<div class="line"><span class="lineno">  219</span>        }</div>
<div class="line"><span class="lineno">  220</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : v-&gt;getIncoming()) {</div>
<div class="line"><span class="lineno">  221</span>            <span class="keyword">auto</span> w = e-&gt;getOrig();</div>
<div class="line"><span class="lineno">  222</span>            <span class="keywordflow">if</span> (!w-&gt;isVisited() &amp;&amp; e-&gt;getFlow() &gt; 0) {</div>
<div class="line"><span class="lineno">  223</span>                w-&gt;setVisited(<span class="keyword">true</span>);</div>
<div class="line"><span class="lineno">  224</span>                w-&gt;setPath(e);</div>
<div class="line"><span class="lineno">  225</span>                q.push(w);</div>
<div class="line"><span class="lineno">  226</span>            }</div>
<div class="line"><span class="lineno">  227</span>        }</div>
<div class="line"><span class="lineno">  228</span>    }</div>
<div class="line"><span class="lineno">  229</span>    <span class="keywordflow">return</span> t-&gt;<a class="code hl_function" href="class_vertex.html#aa4bd82105b85ee53a917391f4811cd8a">isVisited</a>();</div>
<div class="line"><span class="lineno">  230</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa83c8bcf6feb001881f09c5b52f6576f" name="aa83c8bcf6feb001881f09c5b52f6576f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa83c8bcf6feb001881f09c5b52f6576f">&#9670;&#160;</a></span>findMinResidualAlongPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::findMinResidualAlongPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the minimum residual capacity along a path from s to t. This function takes two vertex pointers, s and t, representing the start and end vertices of a path, respectively. It then traverses the path backwards from t to s, calculating the minimum residual capacity along the path as it goes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Pointer to the source vertex of the path. </td></tr>
    <tr><td class="paramname">t</td><td>Pointer to the target vertex of the path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum residual capacity along the path from s to t. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The vertices s and t must belong to the current graph object. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  243</span>                                                           {</div>
<div class="line"><span class="lineno">  244</span>    <span class="keyword">auto</span> e = t-&gt;<a class="code hl_function" href="class_vertex.html#a6e120e57da6af94892fae44e05868794">getPath</a>();</div>
<div class="line"><span class="lineno">  245</span>    <span class="keywordtype">double</span> minResidual = e-&gt;<a class="code hl_function" href="class_edge.html#a1caaffca117bab3ff5b7387623a356f8">getWeight</a>() - e-&gt;getFlow();</div>
<div class="line"><span class="lineno">  246</span>    <span class="keyword">auto</span> v = e-&gt;getOrig();</div>
<div class="line"><span class="lineno">  247</span>    <span class="keywordflow">while</span> (v != s) {</div>
<div class="line"><span class="lineno">  248</span>        e = v-&gt;getPath();</div>
<div class="line"><span class="lineno">  249</span>        <span class="keywordflow">if</span> (e-&gt;getWeight() - e-&gt;getFlow() &lt; minResidual) { <span class="comment">// use edge weight minus current flow</span></div>
<div class="line"><span class="lineno">  250</span>            minResidual = e-&gt;getWeight() - e-&gt;getFlow(); <span class="comment">// use edge weight minus current flow</span></div>
<div class="line"><span class="lineno">  251</span>        }</div>
<div class="line"><span class="lineno">  252</span>        v = e-&gt;getOrig();</div>
<div class="line"><span class="lineno">  253</span>    }</div>
<div class="line"><span class="lineno">  254</span>    <span class="keywordflow">return</span> minResidual;</div>
<div class="line"><span class="lineno">  255</span>}</div>
<div class="ttc" id="aclass_edge_html_a1caaffca117bab3ff5b7387623a356f8"><div class="ttname"><a href="class_edge.html#a1caaffca117bab3ff5b7387623a356f8">Edge::getWeight</a></div><div class="ttdeci">double getWeight() const</div><div class="ttdef"><b>Definition:</b> vertexEdge.cpp:159</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="afe0028a29236a09c9e056a3e7f4c1c08" name="afe0028a29236a09c9e056a3e7f4c1c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe0028a29236a09c9e056a3e7f4c1c08">&#9670;&#160;</a></span>findVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vertex.html">Vertex</a> * Graph::findVertex </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a vertex in the graph given its name. This function iterates through the vertex set of the graph and returns the vertex with the given name, or nullptr if no such vertex exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the vertex to be found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the vertex with the given name, or nullptr if no such vertex exists. Time complexity: O(V), where V is the number of vertices in the graph. The function iterates through the vertex set, which has at most V vertices, until it finds the vertex with the given name or reaches the end of the set. Therefore, the worst-case time complexity is proportional to the number of vertices in the graph. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">   27</span>                                                   {</div>
<div class="line"><span class="lineno">   28</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> v : <a class="code hl_variable" href="class_graph.html#a828b7f04ee093d89fc35aef9b43b2d2e">vertexSet</a>)</div>
<div class="line"><span class="lineno">   29</span>        <span class="keywordflow">if</span> (v-&gt;getName() == name)</div>
<div class="line"><span class="lineno">   30</span>            <span class="keywordflow">return</span> v;</div>
<div class="line"><span class="lineno">   31</span>    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">   32</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa139873f6f134bbf308d33f9837b0d6b" name="aa139873f6f134bbf308d33f9837b0d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa139873f6f134bbf308d33f9837b0d6b">&#9670;&#160;</a></span>findVertexNamex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::findVertexNamex </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the minimum weight along a given path. This function iterates through each vertex in the given path and checks each adjacent edge to find the one connecting the current vertex to the next one. It returns the minimum weight found among these edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A vector of pointers to vertices representing the path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum weight along the path. @complexity O(E), where E is the number of edges in the graph. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">   46</span>                                                   {</div>
<div class="line"><span class="lineno">   47</span>    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; <a class="code hl_variable" href="class_graph.html#a828b7f04ee093d89fc35aef9b43b2d2e">vertexSet</a>.size(); i++)</div>
<div class="line"><span class="lineno">   48</span>        <span class="keywordflow">if</span> (<a class="code hl_variable" href="class_graph.html#a828b7f04ee093d89fc35aef9b43b2d2e">vertexSet</a>[i]-&gt;getName() == name)</div>
<div class="line"><span class="lineno">   49</span>            <span class="keywordflow">return</span> i;</div>
<div class="line"><span class="lineno">   50</span>    <span class="keywordflow">return</span> -1;</div>
<div class="line"><span class="lineno">   51</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa2a93ac9b63627b826766336af064047" name="aa2a93ac9b63627b826766336af064047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2a93ac9b63627b826766336af064047">&#9670;&#160;</a></span>getEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">Edge</a> * Graph::getEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the edge connecting two given vertices in the graph. This function searches for an edge that connects the two given vertices in the graph. It checks all the adjacent edges of the first vertex and returns the edge that connects the first vertex to the second vertex, if such an edge exists. If there is no edge connecting the two vertices, it returns a nullptr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>Pointer to the first vertex. </td></tr>
    <tr><td class="paramname">v2</td><td>Pointer to the second vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the edge connecting the two vertices, or nullptr if there is no such edge. @complexity O(V), where V is the number of vertices in the graph. In the worst case, all the adjacent edges of the first vertex need to be checked before finding the edge that connects the two vertices, which takes O(V) time. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  119</span>                                           {</div>
<div class="line"><span class="lineno">  120</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : v1-&gt;<a class="code hl_function" href="class_vertex.html#a9858f2aa388d2bfb49d9df8f4504b5a0">getAdj</a>()) {</div>
<div class="line"><span class="lineno">  121</span>        <span class="keywordflow">if</span> (e-&gt;getDest() == v2)</div>
<div class="line"><span class="lineno">  122</span>            <span class="keywordflow">return</span> e;</div>
<div class="line"><span class="lineno">  123</span>    }</div>
<div class="line"><span class="lineno">  124</span>    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">  125</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="abb5e0517e2979c54eebdafc2a9875e8f" name="abb5e0517e2979c54eebdafc2a9875e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5e0517e2979c54eebdafc2a9875e8f">&#9670;&#160;</a></span>getNumVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::getNumVertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">    7</span>                              {</div>
<div class="line"><span class="lineno">    8</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="class_graph.html#a828b7f04ee093d89fc35aef9b43b2d2e">vertexSet</a>.size();</div>
<div class="line"><span class="lineno">    9</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a56576f9c2ee0afadc4b77dcbe3acb704" name="a56576f9c2ee0afadc4b77dcbe3acb704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56576f9c2ee0afadc4b77dcbe3acb704">&#9670;&#160;</a></span>getVertexSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; Graph::getVertexSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   11</span>                                           {</div>
<div class="line"><span class="lineno">   12</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="class_graph.html#a828b7f04ee093d89fc35aef9b43b2d2e">vertexSet</a>;</div>
<div class="line"><span class="lineno">   13</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af90483b6ad02aaea613c4fd0ca7a4341" name="af90483b6ad02aaea613c4fd0ca7a4341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90483b6ad02aaea613c4fd0ca7a4341">&#9670;&#160;</a></span>testAndVisit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::testAndVisit </td>
          <td>(</td>
          <td class="paramtype">std::queue&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>residual</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests if a vertex can be visited and adds it to the BFS queue if it can be. This function checks if a vertex has already been visited and if there is still available residual capacity on the edge leading to the vertex. If both conditions are met, the vertex is marked as visited, its path is set to the given edge, and it is added to the BFS queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The BFS queue of vertices to visit. </td></tr>
    <tr><td class="paramname">e</td><td>The edge leading to the vertex being visited. </td></tr>
    <tr><td class="paramname">w</td><td>The vertex being visited. </td></tr>
    <tr><td class="paramname">residual</td><td>The residual capacity of the edge leading to the vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function does not modify the graph itself, only the visited state and path of vertices. </dd>
<dd>
The BFS queue must be passed by reference in order to be modified. </dd>
<dd>
This function is used internally by the edmondsKarp algorithm. @complexity O(1) </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  178</span>                                                                                {</div>
<div class="line"><span class="lineno">  179</span>    <span class="keywordflow">if</span> (! w-&gt;<a class="code hl_function" href="class_vertex.html#aa4bd82105b85ee53a917391f4811cd8a">isVisited</a>() &amp;&amp; residual &gt; 0) {</div>
<div class="line"><span class="lineno">  180</span>        w-&gt;<a class="code hl_function" href="class_vertex.html#a15eeabbbb6d517af746ae137c6d5b595">setVisited</a>(<span class="keyword">true</span>);</div>
<div class="line"><span class="lineno">  181</span>        w-&gt;<a class="code hl_function" href="class_vertex.html#abe4bc30005eec65e775d0cd51f456460">setPath</a>(e);</div>
<div class="line"><span class="lineno">  182</span>        q.push(w);</div>
<div class="line"><span class="lineno">  183</span>    }</div>
<div class="line"><span class="lineno">  184</span>}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9e61864da69191c1896a25a708d1a02d" name="a9e61864da69191c1896a25a708d1a02d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e61864da69191c1896a25a708d1a02d">&#9670;&#160;</a></span>distMatrix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double** Graph::distMatrix = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ae09699c3616af3ebfcb1eb045f2b62" name="a3ae09699c3616af3ebfcb1eb045f2b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae09699c3616af3ebfcb1eb045f2b62">&#9670;&#160;</a></span>pathMatrix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int** Graph::pathMatrix = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a828b7f04ee093d89fc35aef9b43b2d2e" name="a828b7f04ee093d89fc35aef9b43b2d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a828b7f04ee093d89fc35aef9b43b2d2e">&#9670;&#160;</a></span>vertexSet</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="class_vertex.html">Vertex</a> *&gt; Graph::vertexSet</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/goncalomatias/Documents/GitHub/DA1/src/<a class="el" href="new_graph_8h_source.html">newGraph.h</a></li>
<li>/Users/goncalomatias/Documents/GitHub/DA1/src/<a class="el" href="new_graph_8cpp.html">newGraph.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
